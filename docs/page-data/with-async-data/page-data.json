{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/with-async-data","result":{"data":{"markdownRemark":{"html":"<p>在React中，无论是否使用了Redux或其他状态管理框架，都无法避免在组件中处理异步请求。在不使用<code class=\"language-text\">React Hooks</code>的情况下，其典型的流程为：</p>\n<ul>\n<li>在<code class=\"language-text\">componentDidMount</code>中发起异步请求</li>\n<li>调用<code class=\"language-text\">setState</code>在state中维护请求的loading状态，并根据此状态渲染加载动画</li>\n<li>在异步请求resolve的时候调用<code class=\"language-text\">setState</code>将数据放到state中，并将loading状态置为false</li>\n<li>如果异步请求存在异常，则需要处理异常并渲染对应的异常状态</li>\n</ul>\n<p>可以看到整个流程非常琐碎，如果项目中有很多异步组件，则每个组件都要重复地写一次以上流程。\n同时，这个流程存在以下问题：</p>\n<ol>\n<li>如果组件<code class=\"language-text\">unmount</code>之后异步请求才resolve，那么很有可能收到<code class=\"language-text\">Warning: Can’t call setState (or forceUpdate) on an unmounted component.</code>警告</li>\n<li>在实现类似于<code class=\"language-text\">typeahead</code>类型的autocomplete组件或是其他的会频繁发生异步请求的组件中，有可能会发生请求先发后到的问题：先发的请求比后发的请求更慢resolve，导致最后一次渲染结果使用了之前已经过期的输入</li>\n<li>组件除自己的业务逻辑之外还需要维护整套异步请求流程。违反了函数式编程中<code class=\"language-text\">“纯”</code>的概念。一个优秀的纯组件应该仅有输入和输出：重复同一个输入应该幂等地返回同一个渲染结果</li>\n</ol>\n<p>为了解决上述问题，我们将所有异步逻辑抽象到一个高阶组件（HOC）中，并保持真正渲染业务逻辑的组件足够<code class=\"language-text\">“纯”</code>，并且使用Typescript使props类型更为清晰。\n我们把这个HOC叫做<code class=\"language-text\">withAsyncData</code>,源码可以在<a href=\"https://github.com/ChenNima/blog-example/blob/master/front-end/withAsyncData.tsx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这里</a>看到。</p>\n<p>经过包装后的组件总体结构如下图：\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 571px; '>\n      <a class='gatsby-resp-image-link' href='/static/a32c40223fd89494c691be608c55cfa8/ffaf9/arch.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 85.71428571428571%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIBAwX/xAAXAQEBAQEAAAAAAAAAAAAAAAACAAED/9oADAMBAAIQAxAAAAH2oqTdWCqwNo6Z/8QAFxABAQEBAAAAAAAAAAAAAAAAAQAgIf/aAAgBAQABBQJh7MGf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFxEBAAMAAAAAAAAAAAAAAAAAAQAQEf/aAAgBAgEBPwHCyf/EABcQAAMBAAAAAAAAAAAAAAAAAAABMDH/2gAIAQEABj8CMcP/xAAbEAEBAAEFAAAAAAAAAAAAAAABADEQESFxsf/aAAgBAQABPyFm2F6iYDDMg8+RjUv/2gAMAwEAAgADAAAAED/HvP/EABcRAAMBAAAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8Q0UZ//8QAGBEAAwEBAAAAAAAAAAAAAAAAAAEhMVH/2gAIAQIBAT8QXBjjg9MH/8QAHBABAAICAwEAAAAAAAAAAAAAAQAREDEhQVGh/9oACAEBAAE/ELQfR2lsLR2iH1lhxcsBpdcXLAivAYnbjWf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='总体结构' title='总体结构' src='/static/a32c40223fd89494c691be608c55cfa8/ffaf9/arch.jpg' srcset='/static/a32c40223fd89494c691be608c55cfa8/e52aa/arch.jpg 175w,\n/static/a32c40223fd89494c691be608c55cfa8/70ebb/arch.jpg 350w,\n/static/a32c40223fd89494c691be608c55cfa8/ffaf9/arch.jpg 571w' sizes='(max-width: 571px) 100vw, 571px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<h1>🔨 构建HOC</h1>\n<h3><strong>1. 初始状态</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">WithAsyncData</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">Child</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">WithAsyncData</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n    mounted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      isLoadingData<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>我们的HOC接受一个React Component作为参数，返回一个经过包裹的Component。初始我们拥有两个状态：mounted和isLoadingData。顾名思义他们是用来维护组件mount状态和数据loading状态的。由于mount状态并不直接影响渲染结果而只是用来指导是否应该调用<code class=\"language-text\">setState</code>，我们选择把它放在<code class=\"language-text\">this</code>上而不是<code class=\"language-text\">state</code>里。</p>\n<h3><strong>2. 接受异步数据</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> state</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// cleanData这个属性用来表示是否在每次更新数据之后将上次的数据保存在lastData这个state中，主要用于infinityScroll这种场景。</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> cleanData <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> lastData <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 如果data没有改变，直接跳过</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> data <span class=\"token operator\">===</span> lastData <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 如果data是同步数据，那么将isLoadingData置为false，直接将data传递给渲染组件</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isThenable</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      lastData<span class=\"token operator\">:</span> data<span class=\"token punctuation\">,</span>\n      data<span class=\"token punctuation\">,</span>\n      dataPromise<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      isLoadingData<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 如果data是异步请求（这里用thenable表示），那么将isLoadingData置为true，准备请求异步数据</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> newState <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      lastData<span class=\"token operator\">:</span> data<span class=\"token punctuation\">,</span>\n      dataPromise<span class=\"token operator\">:</span> data<span class=\"token punctuation\">,</span>\n      isLoadingData<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cleanData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      newState<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> newState<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>使用<code class=\"language-text\">getDerivedStateFromProps</code>钩子可以在每次渲染之前接收外部传进来的<code class=\"language-text\">data</code>，在这里<code class=\"language-text\">data</code>可以是一个同步数据，也可以是一个异步<code class=\"language-text\">Promise</code>。</p>\n<h3><strong>3. 处理异步数据</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 记录组件mount状态</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mounted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolveAsyncData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps<span class=\"token punctuation\">,</span> prevState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 仅在dataPromise改变的情况下才resolve异步数据</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise <span class=\"token operator\">!==</span> prevState<span class=\"token punctuation\">.</span>dataPromise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolveAsyncData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">shouldKeepResult</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dataPromise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 仅仅在当前Promise是组件接收到的最后一个Promise，并且组件尚未unmount的情况下才会将data真正resolve给渲染组件</span>\n  <span class=\"token keyword\">return</span> dataPromise <span class=\"token operator\">===</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>dataPromise <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mounted<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token function\">resolveAsyncData</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dataPromise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> dataPromise<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 在此处闭包访问dataPromise，即可将resolve的Promise与组件最后接收到的Promise进行对比</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">shouldKeepResult</span><span class=\"token punctuation\">(</span>dataPromise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>onDataReady<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 在数据resolve之后，外部组件的回调钩子</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span><span class=\"token function\">onDataReady</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        data<span class=\"token punctuation\">,</span>\n        isLoadingData<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n        dataPromise<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n        dataError<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">shouldKeepResult</span><span class=\"token punctuation\">(</span>dataPromise<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>onDataError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 在数据resolve 失败之后，外部组件的回调钩子</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span><span class=\"token function\">onDataError</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        dataError<span class=\"token operator\">:</span> error<span class=\"token punctuation\">,</span>\n        isLoadingData<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n        dataPromise<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 组件unmount之前记录状态</span>\n<span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mounted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3><strong>4. 传递数据给子组件</strong></h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 对子组件来说，data是同步数据。将外部传入的promise删除并替换为同步数据，同时将loading状态等state也一同传递</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">omit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Child</span></span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">props</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>至此，我们完成了整个HOC的构建，实际使用时效果如下</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>string</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">(resolve => setTimeout(() => </span><span class=\"token punctuation\">{</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">, 200));\n\nconst RenderComponent = withAsyncData(({ data, isLoadingData }: { data: string, isLoadingData?: boolean }) => (\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token punctuation\">{</span>isLoadingData <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">loading</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token punctuation\">{</span><span class=\"token operator\">!</span>isLoadingData <span class=\"token operator\">&amp;&amp;</span> data <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>data<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n));\nconst ParentComponent = () => (\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RenderComponent</span></span> <span class=\"token attr-name\">data</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>promise<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n);</span></code></pre></div>\n<p><strong>可以看到，外层<code class=\"language-text\">ParentComponent</code>仅仅负责将异步数据传递给了子组件，而内部组件<code class=\"language-text\">RenderComponent</code>也仅仅是将静态内容渲染成了dom。整个异步数据的resolve和状态维持都放在了HOC内部。结构正如一开始的图所描述</strong></p>\n<h1>🚀 改写为Typescript</h1>\n<p>经过HOC包裹后的组件，由接收同步数据变为接收异步数据，其Props的type也发生了相应的改变。为了达到这一目的，我们将HOC进行以下改写：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">PropsType</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"> </span><span class=\"token punctuation\">{</span>\n  data<span class=\"token operator\">:</span> PromiseLike<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"> | T | null;\n  onDataReady?: (data: T) => void;\n  onDataError?: (e: any) => void;\n  cleanData?: boolean;\n}\n\ninterface StateType</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"> </span><span class=\"token punctuation\">{</span>\n  dataPromise<span class=\"token operator\">?</span><span class=\"token operator\">:</span> PromiseLike<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"> | null;\n  data?: T;\n  lastData?: T;\n  isLoadingData: boolean;\n  dataError?: any;\n}\n\nfunction withAsyncData&lt;ChildPropsType extends </span><span class=\"token punctuation\">{</span> data<span class=\"token operator\">?</span><span class=\"token operator\">:</span> any <span class=\"token punctuation\">}</span><span class=\"token plain-text\">>(Child: ComponentType</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ChildPropsType</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">) </span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 真正的data type是由子组件决定的</span>\n  type Data <span class=\"token operator\">=</span> ChildPropsType<span class=\"token punctuation\">[</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 将data type从子组件的props中删除， HOC接收的异步数据最终type为PromiseLike&lt;Data></span>\n  type MixedPropsType <span class=\"token operator\">=</span> Omit<span class=\"token operator\">&lt;</span>ChildPropsType<span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token operator\">></span> <span class=\"token operator\">&amp;</span> PropsType<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Data</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">;\n\n  return class WithAsyncData extends Component&lt;MixedPropsType, StateType</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Data</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">> </span><span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>使用泛型<code class=\"language-text\">&lt;ChildPropsType extends { data?: any }&gt;</code>以及自动类型判断来将要求子组件必须接受<code class=\"language-text\">data</code>属性</li>\n<li>\n<p><code class=\"language-text\">Omit&lt;ChildPropsType, &#39;data&#39;&gt;</code>将data type从子组件的props中删除。在较新的typescript中<code class=\"language-text\">Omit</code>帮助类型的定义在<code class=\"language-text\">node_modules/typescript/lib/lib.es5.d.ts</code>中。如果typescript版本较旧没有该帮助类型，也可以自行polyfill：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">declare type Omit<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> Pick<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> Exclude<span class=\"token operator\">&lt;</span>keyof <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如下图。如果我们使用错误的promise type，那么Typescript就会报错。</p>\n</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; '>\n      <a class='gatsby-resp-image-link' href='/static/64cdeb47ab36016f60e175cf6e0fce07/d30ee/error-example.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 24.571428571428573%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAx0lEQVQY032P7W7DIAxF8zIFGmjAGBYS0kzd+7/T7U1XKdI09ceR5Q8O9iBpQ5IKIVOscNLh9BtXWRGIlwWx3hFyx5gW+LzCshYYY9leuSGOvTF8YdC8Q8uKUhfc8kzRHWN9IOiGiRKfGuIRKb/GmdKGy/GYnMJ+Cift0PYgP/B1h3AokVY7cum4TTNMKDBjhvH6wr7j5V2z/uwNRXduww240XicIjMCN7GBgxQ5Yv9gPuSDlAWZ5wpRbRDKj1NdqL+//iP8xBNTGJyQUt2ihQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='类型错误' title='类型错误' src='/static/64cdeb47ab36016f60e175cf6e0fce07/8c557/error-example.png' srcset='/static/64cdeb47ab36016f60e175cf6e0fce07/4edbd/error-example.png 175w,\n/static/64cdeb47ab36016f60e175cf6e0fce07/13ae7/error-example.png 350w,\n/static/64cdeb47ab36016f60e175cf6e0fce07/8c557/error-example.png 700w,\n/static/64cdeb47ab36016f60e175cf6e0fce07/d30ee/error-example.png 980w' sizes='(max-width: 700px) 100vw, 700px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>","excerpt":"在React中，无论是否使用了Redux或其他状态管理框架，都无法避免在组件中处理异步请求。在不使用的情况下，其典型的流程为： 在中发起异步请求 调用在state中维护请求的loading状态，并根据此状态渲染加载动画 在异步请求resolve的时候调用将数据放到state中，并将loading状态置为false…","frontmatter":{"date":"September 09, 2019","path":"/with-async-data","title":"在React中将异步请求抽象为高阶组件(Typescript)"}}},"pageContext":{}},"staticQueryHashes":["1176552510","3649515864","63159454","846684790"]}