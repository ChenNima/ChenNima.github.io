{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/building-claude-code-plugin-for-agent-teams-zh","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>本文基于 Chorus 项目的实际开发经验，系统介绍 Claude Code 的插件机制，重点探讨如何为 Agent Teams（Swarm 模式）构建插件，以及如何解决多 Agent 协作中的上下文注入难题。</p>\n</blockquote>\n<h2>TL;DR：这篇文章要聊什么</h2>\n<p>Claude Code 的 Agent Teams（也叫 Swarm 模式）让一个 Team Lead Agent 可以并行调度多个 Sub-Agent 协同工作。这是一个强大的能力——但随之而来的问题是：<strong>当你有一个外部工作追踪系统时，怎样让每个 Sub-Agent 自动接入你的工作流，而不是靠 Team Lead 在每个 spawn prompt 里手写一大堆 boilerplate？</strong></p>\n<p>这篇文章的主要目的是：</p>\n<ol>\n<li><strong>介绍 Claude Code 的插件体系</strong>——Marketplace、Plugin Manifest、Hooks、Skills、MCP 配置，这些构成了一套完整的扩展机制</li>\n<li><strong>以 Chorus 为案例</strong>，展示一个 Agent-first 的任务管理平台是如何通过插件无缝接入 Claude Code 多 Agent 工作流的</li>\n<li><strong>深入探讨 Sub-Agent 的上下文注入</strong>——多 Agent 协作场景下，如何让每个 Sub-Agent 自动获得正确的工作上下文，是插件能否真正落地的关键</li>\n</ol>\n<p>如果你正在考虑为自己的工具链（CI/CD、项目管理、监控系统等）编写 Claude Code 插件，希望这篇文章能给你一些启发。</p>\n<hr>\n<h2>一、Claude Code Agent Teams：Swarm 模式速览</h2>\n<p>Agent Teams 是 Claude Code 的多 Agent 协作模式。核心概念很简单：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Team Lead (主 Agent)\n  ├── Task tool ──&gt; Sub-Agent A (frontend-worker)\n  ├── Task tool ──&gt; Sub-Agent B (backend-worker)\n  └── Task tool ──&gt; Sub-Agent C (test-runner)</code></pre></div>\n<p>Team Lead 通过 <code class=\"language-text\">Task</code> 工具 spawn 多个 Sub-Agent，每个 Sub-Agent 是一个独立的 Agent 进程，拥有自己的上下文窗口、工具访问权限、和独立的生命周期。Sub-Agent 之间通过 <code class=\"language-text\">SendMessage</code> 通信，通过共享文件系统协作。</p>\n<p>关键生命周期事件：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>上下文</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">PreToolUse:Task</code></td>\n<td>Team Lead 调用 Task 工具<strong>之前</strong></td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">SubagentStart</code></td>\n<td>Sub-Agent 进程启动时（同步）</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TeammateIdle</code></td>\n<td>Sub-Agent 空闲（完成一轮对话）</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TaskCompleted</code></td>\n<td>Claude Code 内部 Task 标记完成</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">SubagentStop</code></td>\n<td>Sub-Agent 进程退出时</td>\n<td>Team Lead</td>\n</tr>\n</tbody>\n</table>\n<p>注意一个关键事实：<strong>所有这些 Hook 都在 Team Lead 的上下文中触发</strong>，它们的输出（<code class=\"language-text\">additionalContext</code>）注入的是 Team Lead 的对话，而不是 Sub-Agent 的。Sub-Agent 的起始 prompt 完全由 Task 工具的 <code class=\"language-text\">prompt</code> 参数决定——没有任何 Hook 可以直接修改它。</p>\n<p>这意味着，如果你想让 Sub-Agent 自动获得某些上下文信息（比如会话 ID、工作流指令），你需要找到间接的注入方式。这正是本文的核心话题。</p>\n<hr>\n<h2>二、Chorus 是什么，解决什么问题</h2>\n<p>在深入插件实现之前，先简单介绍一下 Chorus。</p>\n<p><a href=\"https://github.com/Chorus-AIDLC/chorus\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chorus</a> 是一个 AI Agent 与人类的协作平台，受 <a href=\"https://aws.amazon.com/blogs/devops/ai-driven-development-life-cycle/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AI-DLC（AI-Driven Development Lifecycle）</a>方法论启发，实现了其中从 Idea 到 Verify 的核心工作流：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Idea → Proposal → [Document + Task] → Execute → Verify → Done\n ^        ^            ^                 ^          ^        ^\nHuman   PM Agent    PM Agent         Dev Agent   Admin    Admin</code></pre></div>\n<p>核心理念是<strong>反转对话</strong>（Reversed Conversation）：AI 提出方案，人类审核和验证——而不是人类下指令、AI 执行。</p>\n<p>在多 Agent 团队场景下，Chorus 需要解决一个具体问题：<strong>可观测性</strong>（Observability）。当 5 个 Sub-Agent 同时在写代码时：</p>\n<ul>\n<li>哪个 Agent 正在处理哪个 Task？</li>\n<li>每个 Agent 的工作进度是什么？</li>\n<li>Task 状态流转（open → in_progress → to_verify → done）是否正确？</li>\n<li>Agent 是否还活着（heartbeat）？</li>\n</ul>\n<p>Chorus 通过 <strong>Session</strong> 机制追踪这一切——每个工作中的 Agent 拥有一个 Session，Session checkin 到 Task 上，UI 实时展示谁在做什么。</p>\n<h3>Chorus 用起来是什么样的</h3>\n<p>文字描述总是抽象的，来看几张实际截图。</p>\n<p><strong>Kanban 看板 — 实时追踪 Agent 工作状态</strong></p>\n<p><img src=\"/ca8741149e0391102f3de54df25fd18e/kanban-auto-update.gif\" alt=\"Kanban 看板\"></p>\n<p>这是 Chorus 的核心视图。每个 Task 卡片上的彩色徽章显示当前正在处理该 Task 的 Agent Session。当 Sub-Agent 调用 <code class=\"language-text\">chorus_session_checkin_task</code> 后，徽章实时出现；调用 <code class=\"language-text\">checkout</code> 后消失。Task 在不同列之间的移动（Open → In Progress → To Verify → Done）由 Agent 通过 MCP 工具驱动。</p>\n<p><strong>Task 依赖图（DAG）</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/372d750d82b62550f37ee3a12b356f25/e6619/dag.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVR42mWSS28TMRSF8zdYUBVIW0jTvDN5NglpHiRt0gJqUIBWiA0LfiQrJHbsswAjGozajMfOTDITz4wPngixwdKRjnR1P5977Rhj7Cvn/M5c3P1i5oIy06ScW5RbFrUYo0vB6e/5T3r9/iMdv7yiF5N3dPT8zVbjF2/pYDylw/PX8/7oFZtef/gck1LOgRDSW6tQetr6UMFfaQ8EsOgPNDtjpAotpPJNPEnXEE+U8OAgj514NlJ4bzeFtNGexTzXvdGdkNILhSkUX1jK4Y5it0xx01LS2yhhC9UfTVTGaCuj3leFSldltY+UK3e0ToLDbAPV5nAWC4NAJ1TYbNwIBJsvsbbXWJoCjrDhSwnBGXqnl8gUn+Io19gm3E+WtynjCQN7iVIY+fLxMw0Mw3/AJRewTIaVBrKFBWFx+L4E18Dh+RTFag86FdJ69CM9eqTDzDEOkpXw4ePi/0Buc1h8Ae4sccs4hL2C9P0tcHA2QbnWQ715GjWiUO0iX+kirVMnc40wka6j3jqbxYLtyNEJVAQOvBU824LvOlAq2FYcx0arewG9QxQ11Kj1kSudYD9Vx45OtruXD+8/yulLevpR1s6XjefdrNf2d89bEdcRxBYmWS05cVc28aVH9Lch/cElKZR7pFDvEKPWIxpI0sUWyRlt7dvf9Bpooz369AczBba+3N6aCQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"DAG\"\n        title=\"\"\n        src=\"/static/372d750d82b62550f37ee3a12b356f25/8c557/dag.png\"\n        srcset=\"/static/372d750d82b62550f37ee3a12b356f25/4edbd/dag.png 175w,\n/static/372d750d82b62550f37ee3a12b356f25/13ae7/dag.png 350w,\n/static/372d750d82b62550f37ee3a12b356f25/8c557/dag.png 700w,\n/static/372d750d82b62550f37ee3a12b356f25/e996b/dag.png 1050w,\n/static/372d750d82b62550f37ee3a12b356f25/2cefc/dag.png 1400w,\n/static/372d750d82b62550f37ee3a12b356f25/e6619/dag.png 3401w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Chorus 中的 Task 可以声明依赖关系，形成有向无环图。PM Agent 在创建 Proposal 时通过 <code class=\"language-text\">dependsOnDraftUuids</code> 设置依赖。UI 使用 dagre 自动布局。Team Lead 可以据此决定 spawn 顺序——先处理没有依赖的 Task，被依赖的 Task 完成后，下游 Task 自动解除阻塞。</p>\n<p><strong>Proposal — AI 提出方案，人类审核</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/7e117/proposal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5klEQVR42pVT207cMBDN/38CD+0Dn4KouoRW26qt1D4hBGVLdxPi29ie8U5nnCWbgIrA0dE4sX3meM6keej7U+/9V0xpNfTb1gy71vSCbttaiWCHNgbbgjNtkPl/sPLm4Zs13bsmQlzzOAomx3+3d7y9/83d5ob7+1sedhu2Q8c5Bd0ioBke31EnnBJcNCGEzyNdweBtcdYUgFCRUyxJEaEgplIIKwhzIcolgq9rhAmVQm7ysTHDsCZC1g0QPHsfWJIwhDHO4ZxjAOCcMyOixCTniA9SZY9dNcH79SiQSgyOjRk4RmCSAygHc0oSl9A1kciiTq6ZJkJrzaqRTJWQxqswyCYxqSoppfBLA3MUwljP6jsEdyTU2uQEHLwT6b4iQtDvqv4YZ8AMDLZXjISwICQtciV67ciiMDirV6+EcU6osjXrNPb7sX5qmBog80L0hDAtaig3eoFQXVNXxV111BlT44JQ6pdilO/5FQrHjIeiE4MYRU8VylqMR4UHU/JEqC2xUCgkCjXLW/vMdU3mQEzMcOxDKuXy4LLU1mvvTJA2knxJfhKocb6mChxY/P7nJ365+5FuYSMt5z5MCh9lv2Xs5aE9zRv7otld/XofrL2UhGfR2/O3ALwTwLlwnXW77tPN9fXJP6aviRvxk9S7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Proposal\"\n        title=\"\"\n        src=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/8c557/proposal.png\"\n        srcset=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/4edbd/proposal.png 175w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/13ae7/proposal.png 350w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/8c557/proposal.png 700w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/e996b/proposal.png 1050w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/2cefc/proposal.png 1400w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/7e117/proposal.png 1715w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>这是 AI-DLC 的核心理念\"反转对话\"的体现：PM Agent 分析 Idea 后，创建包含 PRD 文档草案和 Task 草案的 Proposal。Admin（人类）审核通过后，草案自动物化为真实的 Document 和 Task 实体。</p>\n<p><strong>Task 详情 — Session 追踪</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/7e117/task-tracking.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPUlEQVR42qWTy07cQBBF/f9fkEWyyQdkk03QjD3uh91t95h5kR0LQCGBgN/Gj+lpimqbERBlBS1ddZdGc3xLt8rxPP8r53wrhIjmJz+U584U8Vzl4+17cxVQ8kaM+EoETP36c62y62t1//dWVVUVtW1zVlfVF0dKudput7BZr0wYMJCCwTIWo2TIIFECJUFF4Sj7XiUxNE0NQ9dBb9X3BvB0XScdxtgpHlBxpBmZm6M4W5gF3vgR45OZ8f2Zof4cNTMhX5gsS02aZubu7s4URaEtsG1b4VBKVkmSQBRJw6kHCBsVcB88zwXXdYFRgvUCOHUBgRAGPhRFDnVdQ1mW+C5Hh+gUHVI6AeUEtH+yskBKCBBKQUgBAZuA9mMh/lYWGQyDbbeFrn0wk8NGOnEcr87OfkIcReYIG4EICAMOYciBBeQ/wBz2Qw/7fQ9D343Apq7lGMput0Og/Af44naS9xaYp/BQV6gSmsq2bCDP0w8AywJTbbHtHtueHNa25fcCbSjDMMDj4yMYPGPLzXuBmHKW3o8JI8SOy/Mcth9wmOd2kDGUPWitX8bmvcD09jfU6M5uSvswjQ2uoHSiKF6u1xsLHDid66MC5urXNcLGm5GZFgHRWZrqq6srfXl5qS8uLoabmxvAd+Csk2R1fn4Ou+3GLOMAjkpUCG/qeKpVxOF0KewwYxgHOBwO6G0KBVuXjvv922fOWCyFILirDFfrWa/fM8afa+Kf4Ca6DAebYbgMR4bpgybmoFVbl5+eAFrvAC8u8QdyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Task Tracking\"\n        title=\"\"\n        src=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/8c557/task-tracking.png\"\n        srcset=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/4edbd/task-tracking.png 175w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/13ae7/task-tracking.png 350w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/8c557/task-tracking.png 700w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/e996b/task-tracking.png 1050w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/2cefc/task-tracking.png 1400w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/7e117/task-tracking.png 1715w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Task 详情页展示了完整的工作历史：哪些 Session 曾经 checkin 过这个 Task，每次 checkin/checkout 的时间，以及 Agent 提交的工作报告。这就是 Chorus 的可观测性——即使 5 个 Agent 同时工作，你也能清楚看到每个人在做什么。</p>\n<p><strong>像素办公室 — Agent 的虚拟工位</strong></p>\n<p><img src=\"/f9e773e8262d031c6edf6ba5be789074/pixcel-workspace.gif\" alt=\"Pixel Workspace\"></p>\n<p>这是 Chorus 的趣味功能：每个活跃的 Agent Session 在像素办公室里有自己的工位。Agent checkin 到 Task 时开始\"工作\"动画，idle 时休息，完成时庆祝。纯粹的可视化娱乐，但能一眼看出团队的工作状态。</p>\n<hr>\n<h2>三、为什么要写 Claude Code 插件</h2>\n<p>没有插件之前，Team Lead 需要在每个 Sub-Agent 的 spawn prompt 里手写大量 boilerplate：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Task<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"frontend-worker\"</span><span class=\"token punctuation\">,</span>\n  prompt<span class=\"token punctuation\">:</span> <span class=\"token triple-quoted-string string\">\"\"\"\n    你的 Chorus session UUID: ???（Team Lead 还不知道，因为 session 还没创建）\n    你的 Chorus task UUID: task-A-uuid\n\n    工作前：\n    1. 创建 session: chorus_create_session(...)\n    2. Checkin: chorus_session_checkin_task(sessionUuid, taskUuid)\n    3. 更新状态: chorus_update_task(taskUuid, \"in_progress\", sessionUuid)\n\n    工作中：\n    4. 汇报进度: chorus_report_work(taskUuid, report, sessionUuid)\n\n    完成后：\n    5. Checkout: chorus_session_checkout_task(sessionUuid, taskUuid)\n    6. 提交验证: chorus_submit_for_verify(taskUuid, summary)\n    7. 关闭 session: chorus_close_session(sessionUuid)\n  \"\"\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>问题显而易见：</p>\n<ol>\n<li><strong>Session UUID 不可能预知</strong>——Session 需要调用 MCP 才能创建，但 prompt 在 spawn 之前就要写好</li>\n<li><strong>每个 Sub-Agent 的 prompt 里重复同样的 boilerplate</strong>——6-7 步工作流指令，占据大量 prompt 空间</li>\n<li><strong>Team Lead 必须记住所有步骤</strong>——忘了 checkout？忘了 heartbeat？Session 就会失效</li>\n<li><strong>Session 生命周期管理复杂</strong>——创建、复用、重开、心跳、关闭，全靠手动</li>\n</ol>\n<p>有了插件，这一切可以自动化：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Task<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"frontend-worker\"</span><span class=\"token punctuation\">,</span>\n  prompt<span class=\"token punctuation\">:</span> <span class=\"token triple-quoted-string string\">\"\"\"\n    你的 Chorus task UUID: task-A-uuid\n    读取 .chorus/sessions/frontend-worker.json，按里面的 workflow 指令操作。\n    然后实现前端用户表单组件...\n  \"\"\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>从 15 行 boilerplate 到 3 行。其余的全部由插件在 Hook 中自动处理。</p>\n<hr>\n<h2>四、Claude Code 插件体系全览</h2>\n<p>Claude Code 的插件是一个目录，包含以下组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">my-plugin/\n├── .claude-plugin/\n│   └── plugin.json          # 插件清单（元数据）\n├── .mcp.json                # MCP 服务器配置\n├── hooks/\n│   └── hooks.json           # Hook 配置\n├── bin/                     # Hook 脚本\n│   ├── on-session-start.sh\n│   └── on-subagent-start.sh\n└── skills/\n    └── my-skill/\n        ├── SKILL.md         # 技能入口文件\n        └── references/      # 参考文档</code></pre></div>\n<p>下面逐一介绍各组件。</p>\n<h3>4.1 Plugin Manifest（plugin.json）</h3>\n<p>位于 <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/.claude-plugin/plugin.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">.claude-plugin/plugin.json</code></a>，是插件的身份证：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chorus\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"description\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Chorus AI-DLC collaboration platform plugin...\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.1.3\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"author\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Chorus-AIDLC\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"homepage\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://github.com/Chorus-AIDLC/chorus\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"license\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"AGPL-3.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"keywords\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"ai-dlc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"multi-agent\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"session\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">plugin.json</code> 是可选的——如果省略，Claude Code 会从目录名推断插件名称，并自动发现各组件。但推荐总是提供，便于版本管理和分发。</p>\n<h3>4.2 Marketplace（插件市场）</h3>\n<p>插件通过 Marketplace 分发。Marketplace 本质上是一个 JSON 清单文件（<a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/.claude-plugin/marketplace.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">.claude-plugin/marketplace.json</code></a>），放在 GitHub 公开仓库中即可。Chorus 就是用自己的 GitHub 仓库作为 Marketplace：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chorus-plugins\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"owner\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Chorus-AIDLC\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chorus\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"source\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./public/chorus-plugin\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"description\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Chorus AI-DLC collaboration platform plugin...\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.1.3\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"category\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"project-management\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"ai-dlc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"collaboration\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mcp\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"session\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>用户安装 Chorus 插件的实际流程：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 1. 添加 marketplace — 指向 GitHub 仓库（仓库中包含 .claude-plugin/marketplace.json）</span>\n/plugin marketplace <span class=\"token function\">add</span> Chorus-AIDLC/chorus\n\n<span class=\"token comment\"># 2. 安装插件 — 格式为 插件名@marketplace名</span>\n/plugin <span class=\"token function\">install</span> chorus@chorus-plugins\n\n<span class=\"token comment\"># 3. 可以指定作用域</span>\n/plugin <span class=\"token function\">install</span> chorus@chorus-plugins --scope project  <span class=\"token comment\"># 项目级（团队共享，提交到 git）</span>\n/plugin <span class=\"token function\">install</span> chorus@chorus-plugins --scope <span class=\"token builtin class-name\">local</span>    <span class=\"token comment\"># 本地级（仅自己）</span></code></pre></div>\n<p><code class=\"language-text\">source</code> 字段指向插件在仓库中的相对路径。除了本地路径，还支持指向其他 GitHub repo（<code class=\"language-text\">&quot;source&quot;: {&quot;source&quot;: &quot;github&quot;, &quot;repo&quot;: &quot;owner/repo&quot;}</code>）或 Git URL 等来源。</p>\n<h3>4.3 MCP 配置（<a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/.mcp.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.mcp.json</a>）</h3>\n<p>插件可以自带 MCP Server 配置，安装后自动生效：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"mcpServers\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"chorus\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${CHORUS_URL}/api/mcp\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"headers\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"Authorization\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Bearer ${CHORUS_API_KEY}\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">${CHORUS_URL}</code> 和 <code class=\"language-text\">${CHORUS_API_KEY}</code> 是环境变量——Claude Code 在运行时自动替换。用户只需设置环境变量，插件就能连接到正确的服务。</p>\n<p>这意味着：<strong>插件安装后，所有 MCP 工具自动可用</strong>。Sub-Agent 也能访问（前提是 MCP 配置在项目级别，而不是用户级别）。</p>\n<p><strong>Chorus 的 MCP 配置</strong>：Chorus 通过 HTTP Streamable Transport 暴露了 50+ 个 MCP 工具，按角色分组（公共工具、PM 工具、Developer 工具、Admin 工具、Session 工具）。用户只需设置两个环境变量 <code class=\"language-text\">CHORUS_URL</code> 和 <code class=\"language-text\">CHORUS_API_KEY</code>，插件就能连接到 Chorus 服务。API Key 以 <code class=\"language-text\">cho_</code> 前缀开头，携带 Agent 角色信息，服务端据此决定哪些工具可见。</p>\n<h3>4.4 Skills（技能系统）</h3>\n<p>Skills 是插件内置的指令集，Claude 可以在需要时自动调用，用户也可以通过 <code class=\"language-text\">/skill-name</code> 手动触发。</p>\n<p>一个 Skill 由一个 <code class=\"language-text\">SKILL.md</code> 入口文件和可选的 <code class=\"language-text\">references/</code> 参考文档组成：</p>\n<div class=\"gatsby-highlight\" data-language=\"markdown\"><pre class=\"language-markdown\"><code class=\"language-markdown\"><span class=\"token hr punctuation\">---</span>\nname: chorus\ndescription: Chorus AI Agent collaboration platform Skill...\nmetadata:\n  author: chorus\n  version: \"0.1.1\"\n  category: project-management\n  <span class=\"token title important\">mcp_server: chorus\n<span class=\"token punctuation\">---</span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">#</span> Chorus Skill</span>\n\nThis Skill guides AI Agents on how to use Chorus MCP tools...\n\n<span class=\"token title important\"><span class=\"token punctuation\">##</span> Skill Files</span>\n\n<span class=\"token table\"><span class=\"token table-header-row\"><span class=\"token punctuation\">|</span><span class=\"token table-header important\"> File </span><span class=\"token punctuation\">|</span><span class=\"token table-header important\"> Description </span><span class=\"token punctuation\">|</span>\n</span><span class=\"token table-line\"><span class=\"token punctuation\">|</span><span class=\"token punctuation\">------</span><span class=\"token punctuation\">|</span><span class=\"token punctuation\">-------------</span><span class=\"token punctuation\">|</span>\n</span><span class=\"token table-data-rows\"><span class=\"token punctuation\">|</span><span class=\"token table-data\"> <span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">references/02-pm-workflow.md</span><span class=\"token punctuation\">**</span></span> </span><span class=\"token punctuation\">|</span><span class=\"token table-data\"> PM Agent workflow </span><span class=\"token punctuation\">|</span>\n<span class=\"token punctuation\">|</span><span class=\"token table-data\"> <span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">references/03-developer-workflow.md</span><span class=\"token punctuation\">**</span></span> </span><span class=\"token punctuation\">|</span><span class=\"token table-data\"> Developer Agent workflow </span><span class=\"token punctuation\">|</span>\n<span class=\"token punctuation\">|</span><span class=\"token table-data\"> <span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">references/06-claude-code-agent-teams.md</span><span class=\"token punctuation\">**</span></span> </span><span class=\"token punctuation\">|</span><span class=\"token table-data\"> Agent Teams integration </span><span class=\"token punctuation\">|</span></span></span></code></pre></div>\n<p><strong>Chorus 的 Skill 体系</strong>：Chorus 包含 <a href=\"https://github.com/Chorus-AIDLC/Chorus/tree/main/public/chorus-plugin/skills/chorus/references\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">7 个参考文档</a>（<code class=\"language-text\">references/00</code> 到 <code class=\"language-text\">references/06</code>），覆盖从公共工具、PM 工作流、Developer 工作流、Admin 工作流，到 Session 管理和 Agent Teams 集成的完整指南。当 Agent 调用 <code class=\"language-text\">/chorus</code> 或 Claude 判断需要 Chorus 知识时，Skill 文档自动加载到上下文中。这相当于给每个 Agent 一本随身携带的操作手册——无论是 Team Lead 还是 Sub-Agent，都能通过 Skill 了解正确的工作流程。</p>\n<p>Skill 的 frontmatter 支持丰富的配置项：</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">---</span>\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> my<span class=\"token punctuation\">-</span>skill\n<span class=\"token key atrule\">description</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"When to use this skill\"</span>\n<span class=\"token key atrule\">allowed-tools</span><span class=\"token punctuation\">:</span> Read<span class=\"token punctuation\">,</span> Grep<span class=\"token punctuation\">,</span> Glob     <span class=\"token comment\"># 允许无需权限使用的工具</span>\n<span class=\"token key atrule\">model</span><span class=\"token punctuation\">:</span> claude<span class=\"token punctuation\">-</span>opus<span class=\"token punctuation\">-</span>4<span class=\"token punctuation\">-</span><span class=\"token number\">6</span>              <span class=\"token comment\"># 指定模型</span>\n<span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> fork                       <span class=\"token comment\"># 在 subagent 中运行</span>\n<span class=\"token key atrule\">disable-model-invocation</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>      <span class=\"token comment\"># 仅用户可触发（Claude 不会自动调用）</span>\n<span class=\"token punctuation\">---</span></code></pre></div>\n<h3>4.5 Hooks（钩子系统）</h3>\n<p>Hooks 是插件的核心——它们让你在 Claude Code 生命周期的关键节点执行自定义逻辑。</p>\n<p>配置在 <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/hooks/hooks.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">hooks/hooks.json</code></a>：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"SessionStart\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"matcher\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"startup|resume|compact\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"command\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"command\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${CLAUDE_PLUGIN_ROOT}/bin/on-session-start.sh\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"SubagentStart\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"command\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"command\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${CLAUDE_PLUGIN_ROOT}/bin/on-subagent-start.sh\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"SubagentStop\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"command\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"command\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${CLAUDE_PLUGIN_ROOT}/bin/on-subagent-stop.sh\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"async\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Hook 类型</h4>\n<p>Claude Code 支持三种 Hook 执行方式：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">command</code></td>\n<td>执行 shell 命令，通过 stdin 接收事件 JSON，通过 stdout 输出结果</td>\n<td>大多数场景</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">prompt</code></td>\n<td>用 LLM 评估决策，模型返回 <code class=\"language-text\">{ok: true/false}</code></td>\n<td>需要智能判断时（如代码审查）</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">agent</code></td>\n<td>spawn 一个有工具访问权限的 subagent 来验证</td>\n<td>需要执行复杂多步验证时（如跑测试）</td>\n</tr>\n</tbody>\n</table>\n<p>Chorus 插件的所有 Hook 都使用 <code class=\"language-text\">command</code> 类型——因为 Chorus 的 Hook 逻辑是确定性的（调 API、读写文件、管理状态），不需要 LLM 判断。<code class=\"language-text\">prompt</code> 和 <code class=\"language-text\">agent</code> 更适合需要\"理解\"代码内容才能做决策的场景，比如在 <code class=\"language-text\">Stop</code> 事件中用 <code class=\"language-text\">agent</code> 类型自动跑测试来判断任务是否真的完成。</p>\n<h4>Hook 事件全表</h4>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>能否阻断</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">SessionStart</code></td>\n<td>会话开始/恢复/compact</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">UserPromptSubmit</code></td>\n<td>用户提交输入</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PreToolUse</code></td>\n<td>工具执行前</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PostToolUse</code></td>\n<td>工具执行后</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">SubagentStart</code></td>\n<td>Sub-Agent 启动</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">SubagentStop</code></td>\n<td>Sub-Agent 退出</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TeammateIdle</code></td>\n<td>Sub-Agent 空闲</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">TaskCompleted</code></td>\n<td>CC Task 完成</td>\n<td>是</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">SessionEnd</code></td>\n<td>会话结束</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h4>Hook 输出格式</h4>\n<p>知道有哪些事件后，下一个问题是：<strong>Hook 脚本能返回什么来影响 Claude 的行为？</strong> Hook 通过 stdout 输出 JSON：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"systemMessage\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"用户可见的通知消息\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"hookSpecificOutput\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"hookEventName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"SubagentStart\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"additionalContext\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"这段文字会注入到 Claude 的上下文中\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"permissionDecision\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"allow\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>关键字段：</p>\n<ul>\n<li><strong><code class=\"language-text\">systemMessage</code></strong>：显示在 Claude Code UI 中的通知，用户可见</li>\n<li><strong><code class=\"language-text\">additionalContext</code></strong>：注入到 LLM 的 system context 中——<strong>这是 Hook 影响 Claude 行为的主要手段</strong>。Chorus 的 <code class=\"language-text\">SessionStart</code> Hook 就是通过它把 checkin 结果（身份、任务、通知）注入到 Agent 上下文的</li>\n<li><strong><code class=\"language-text\">permissionDecision</code></strong>：<code class=\"language-text\">allow</code> / <code class=\"language-text\">deny</code> / <code class=\"language-text\">ask</code>，用于 <code class=\"language-text\">PreToolUse</code> 控制工具执行权限</li>\n<li><strong><code class=\"language-text\">suppressOutput</code></strong>：设为 <code class=\"language-text\">true</code> 可静默输出——Chorus 的 <code class=\"language-text\">TeammateIdle</code> Hook 用它来避免每次心跳都弹通知</li>\n</ul>\n<h4>同步 vs 异步</h4>\n<ul>\n<li><strong>同步 Hook</strong>（默认）：阻塞 Claude 直到完成。适合需要立即影响的场景——Chorus 的 <code class=\"language-text\">SubagentStart</code> 必须同步，因为它要在 Sub-Agent 开始工作前创建好 session 并写入 session file</li>\n<li><strong>异步 Hook</strong>（<code class=\"language-text\">&quot;async&quot;: true</code>）：后台运行，不阻塞。适合不影响流程的场景——Chorus 的 <code class=\"language-text\">SubagentStop</code>（清理资源）和 <code class=\"language-text\">TeammateIdle</code>（心跳）都是异步的</li>\n</ul>\n<h4>每个 Hook 事件 Chorus 用它做什么</h4>\n<p>了解了事件、输出格式、同步/异步之后，来看 Chorus 插件如何具体使用每个 Hook。</p>\n<p><strong><code class=\"language-text\">SessionStart</code> — Checkin + 上下文注入</strong></p>\n<p>这是插件的\"开机自检\"。Chorus 在这里做三件事：</p>\n<ol>\n<li>调用 <code class=\"language-text\">chorus_checkin()</code> MCP 工具，获取当前 Agent 的身份（角色、名称、人格）、已分配的 Idea 和 Task、未读通知</li>\n<li>将完整的 checkin 结果通过 <code class=\"language-text\">additionalContext</code> 注入到 Claude 的上下文中——Agent 一启动就知道自己是谁、该做什么</li>\n<li>扫描 <code class=\"language-text\">.chorus/sessions/</code> 目录，列出已有的 Sub-Agent session 文件——这是为了处理 Claude Code 会话中断后恢复的情况：上次的 Sub-Agent session 文件可能还在，Team Lead 恢复后需要知道哪些 session 仍然存在</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># on-session-start.sh 核心逻辑</span>\n<span class=\"token assign-left variable\">CHECKIN_RESULT</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span>\"$API<span class=\"token string\">\" mcp-tool \"</span>chorus_checkin\" <span class=\"token string\">'{}'</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token assign-left variable\">CONTEXT</span><span class=\"token operator\">=</span><span class=\"token string\">\"# Chorus Plugin — Active\nChorus is connected at <span class=\"token variable\">${CHORUS_URL}</span>.\n## Checkin Result\n<span class=\"token variable\">${CHECKIN_RESULT}</span>\n## Session Management — IMPORTANT\nThe Chorus Plugin fully automates session lifecycle...\nDo NOT call chorus_create_session for sub-agents.\"</span>\n\n<span class=\"token string\">\"<span class=\"token variable\">$API</span>\"</span> hook-output <span class=\"token string\">\"<span class=\"token variable\">$USER_MSG</span>\"</span> <span class=\"token string\">\"<span class=\"token variable\">$CONTEXT</span>\"</span> <span class=\"token string\">\"SessionStart\"</span></code></pre></div>\n<p>效果：Agent 在第一轮对话就拥有了完整的项目上下文和行为指南，不需要用户手动告知。</p>\n<p><strong><code class=\"language-text\">UserPromptSubmit</code> — 轻量级状态提醒</strong></p>\n<p>每次用户输入都会触发，所以必须极快（&#x3C;100ms）。Chorus 在这里<strong>不做任何网络调用</strong>，只做本地文件检查：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># on-user-prompt.sh — 纯本地操作，不调 MCP</span>\n<span class=\"token comment\"># 统计 .chorus/sessions/ 下的 json 文件数量</span>\n<span class=\"token assign-left variable\">CONTEXT</span><span class=\"token operator\">=</span><span class=\"token string\">\"[Chorus Plugin Active]\n- Active sub-agent sessions (3): frontend-worker, backend-worker, test-runner\"</span></code></pre></div>\n<p>这给 Team Lead 一个持续的状态感知：当前有几个 Sub-Agent session 在运行。</p>\n<p><strong><code class=\"language-text\">PreToolUse</code> — 工作流引导（3 个子 Hook）</strong></p>\n<p>Chorus 注册了 3 个 <code class=\"language-text\">PreToolUse</code> Hook，分别匹配不同的工具：</p>\n<table>\n<thead>\n<tr>\n<th>matcher</th>\n<th>脚本</th>\n<th>Chorus 做什么</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">EnterPlanMode</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-enter-plan.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">on-pre-enter-plan.sh</code></a></td>\n<td>注入 Chorus Proposal 工作流指南——\"先创建 Proposal，设置 Task 依赖 DAG，提交审批后再编码\"</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">ExitPlanMode</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-exit-plan.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">on-pre-exit-plan.sh</code></a></td>\n<td>提醒检查——\"退出 Plan Mode 前确认 Proposal 已创建并提交\"</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Task</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-spawn-agent.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">on-pre-spawn-agent.sh</code></a></td>\n<td>捕获 Sub-Agent 的 name/type 写入 pending 文件；通过 <code class=\"language-text\">additionalContext</code> 提醒 Team Lead 在 prompt 中包含 task UUID</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">EnterPlanMode</code> 和 <code class=\"language-text\">ExitPlanMode</code> 展示了一个有趣的用法：<strong>用 Hook 引导 Agent 遵循特定的工作流程</strong>。当 Agent 进入 Plan Mode 时，Chorus 自动注入\"先创建 Proposal 再编码\"的指导；退出 Plan Mode 时，检查是否已有 Proposal。这不是强制阻断（<code class=\"language-text\">permissionDecision</code> 仍然是 <code class=\"language-text\">allow</code>），而是通过 <code class=\"language-text\">additionalContext</code> 做软性引导。</p>\n<p><strong><code class=\"language-text\">SubagentStart</code> — Session 自动创建 + PE 注入</strong>（核心）</p>\n<p>这是 Chorus 插件最核心的 Hook，详见第五章。简要概括：认领 pending 文件 → 创建/复用 Session → 写 session file（含 workflow PE）→ 存储状态映射。</p>\n<p><strong><code class=\"language-text\">SubagentStop</code> — 自动清理 + 任务发现</strong></p>\n<p>异步执行，做四件事：(1) 批量 checkout 所有未关闭的 task checkin，(2) 关闭 Session，(3) 清理本地文件和状态，(4) 查询项目中新解除阻塞的 Task 并通过 <code class=\"language-text\">additionalContext</code> 通知 Team Lead——这一步非常有价值，它实现了<strong>自动任务调度发现</strong>：当一个前置 Task 完成后，下游 Task 自动解除阻塞，Team Lead 立即得到通知可以分配新工作。</p>\n<p><strong><code class=\"language-text\">TeammateIdle</code> — 自动心跳</strong></p>\n<p>异步 + <code class=\"language-text\">suppressOutput: true</code>。只做一件事：调 <code class=\"language-text\">chorus_session_heartbeat</code> 保持 Session 活跃。Chorus 的 Session 超过 1 小时没有心跳会自动标记为 inactive——这个 Hook 确保只要 Sub-Agent 还在运行，Session 就不会失活。</p>\n<p><strong><code class=\"language-text\">TaskCompleted</code> — 元数据桥接</strong></p>\n<p>当 Claude Code 内部的 Task 标记完成时，Chorus 检查 task 描述中是否包含 <code class=\"language-text\">chorus:task:&lt;uuid&gt;</code> 标签。如果有，自动执行 <code class=\"language-text\">chorus_session_checkout_task</code>。这是一个优雅的<strong>元数据桥接</strong>模式——通过在 CC Task 描述中嵌入 Chorus task UUID，让两个系统的 Task 生命周期联动。</p>\n<p><strong><code class=\"language-text\">SessionEnd</code> — 清理 .chorus/ 目录</strong></p>\n<p>会话结束时，检查是否所有 session 文件都已清理、state.json 是否为空。如果是，删除整个 <code class=\"language-text\">.chorus/</code> 目录，不留垃圾文件。</p>\n<hr>\n<h2>五、Chorus 插件的完整实现</h2>\n<p>现在进入正题——Chorus 插件是如何利用上述机制解决多 Agent 协作问题的。</p>\n<h3>5.1 整体架构</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Team Lead 调用 Task 工具 spawn Sub-Agent\n  │\n  ├─ [PreToolUse:Task] on-pre-spawn-agent.sh\n  │    写入 .chorus/pending/&lt;name&gt; 文件（捕获 agent name）\n  │    向 Team Lead 注入提醒：&quot;在 prompt 里包含 task UUID&quot;\n  │\n  ├─ [SubagentStart] on-subagent-start.sh    ← 核心\n  │    认领 pending 文件（原子 mv，处理并发）\n  │    创建/复用/重开 Chorus Session（MCP 调用）\n  │    写入 .chorus/sessions/&lt;name&gt;.json（含 workflow PE）\n  │    存储 state 映射（agent_id ↔ session_uuid）\n  │\n  ├─ Sub-Agent 开始执行\n  │    读取 .chorus/sessions/&lt;name&gt;.json → 获得 sessionUuid + 工作流指令\n  │    按 workflow 字段自主执行 checkin → in_progress → report → checkout → submit\n  │\n  ├─ [TeammateIdle] on-teammate-idle.sh（异步）\n  │    发送 session heartbeat，保持 session 活跃\n  │\n  ├─ [TaskCompleted] on-task-completed.sh\n  │    检测 chorus:task:&lt;uuid&gt; 标签，自动 checkout\n  │\n  └─ [SubagentStop] on-subagent-stop.sh（异步）\n       批量 checkout 所有 task\n       关闭 Chorus Session\n       清理本地状态\n       查询并展示新解除阻塞的 task</code></pre></div>\n<h3>5.2 <code class=\"language-text\">.chorus/</code> 目录：连接一切的桥梁</h3>\n<p>前面多次提到\"共享文件系统\"，现在展开说。Chorus 插件在项目根目录下维护一个 <code class=\"language-text\">.chorus/</code> 目录（gitignored），它是 Team Lead、Sub-Agent、和所有 Hook 之间的信息枢纽：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.chorus/                              # 插件运行时状态（gitignored）\n├── state.json                        # 全局状态 KV 存储\n├── state.json.lock                   # flock 排他锁文件\n├── sessions/                         # Sub-Agent session 文件（含 workflow PE）\n│   ├── frontend-worker.json\n│   ├── backend-worker.json\n│   └── test-runner.json\n├── pending/                          # PreToolUse:Task 写入，等待 SubagentStart 认领\n│   └── &lt;agent-name&gt;\n└── claimed/                          # SubagentStart 认领后的文件\n    └── &lt;agent-id&gt;</code></pre></div>\n<h4>核心：<code class=\"language-text\">state.json</code> — 跨 Hook 的状态共享</h4>\n<p>每个 Hook 都是独立的 shell 进程，它们不共享内存。<code class=\"language-text\">state.json</code> 是所有 Hook 之间的共享状态存储：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"session_a0ed860\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"699f8ed4-4a98-4522-8321-662a2222a180\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"agent_for_session_699f8ed4-...\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"a0ed860\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"session_frontend-worker\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"699f8ed4-...\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"name_for_agent_a0ed860\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"frontend-worker\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"main_session_uuid\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"...\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>存储的是四组映射关系：<code class=\"language-text\">agent_id → session_uuid</code>、<code class=\"language-text\">session_uuid → agent_id</code>、<code class=\"language-text\">agent_name → session_uuid</code>、<code class=\"language-text\">agent_id → agent_name</code>。这样任何 Hook 只要知道其中一个 ID，就能查到其余所有关联信息。</p>\n<h4>并发写入保护：flock</h4>\n<p>当 5 个 Sub-Agent 同时 spawn 时，5 个 <code class=\"language-text\">SubagentStart</code> Hook 会并发执行，每个都要往 <code class=\"language-text\">state.json</code> 写入 4 个 key。如果不做保护，JSON 文件会被并发写入损坏。</p>\n<p>Chorus 在 <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/chorus-api.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">chorus-api.sh</code></a> 中用 <code class=\"language-text\">flock</code> 排他锁解决这个问题：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># chorus-api.sh 中的 state_set 实现</span>\n<span class=\"token function-name function\">state_set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin class-name\">local</span> <span class=\"token assign-left variable\">key</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$1</span>\"</span> <span class=\"token assign-left variable\">value</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$2</span>\"</span>\n  <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\"># 获取排他锁，超时 5 秒</span>\n    flock -w <span class=\"token number\">5</span> <span class=\"token number\">200</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"WARN: flock timeout\"</span> <span class=\"token operator\">></span><span class=\"token file-descriptor important\">&amp;2</span><span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\"># 在锁保护下修改 JSON</span>\n    jq --arg k <span class=\"token string\">\"<span class=\"token variable\">$key</span>\"</span> --arg <span class=\"token function\">v</span> <span class=\"token string\">\"<span class=\"token variable\">$value</span>\"</span> <span class=\"token string\">'.[<span class=\"token variable\">$k</span>] = <span class=\"token variable\">$v</span>'</span> <span class=\"token string\">\"<span class=\"token variable\">$STATE_FILE</span>\"</span> <span class=\"token operator\">></span> <span class=\"token string\">\"<span class=\"token variable\">$tmp</span>\"</span> <span class=\"token punctuation\">\\</span>\n      <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">mv</span> <span class=\"token string\">\"<span class=\"token variable\">$tmp</span>\"</span> <span class=\"token string\">\"<span class=\"token variable\">$STATE_FILE</span>\"</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token number\">20</span><span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>></span><span class=\"token string\">\"<span class=\"token variable\">${STATE_FILE}</span>.lock\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>关键细节：</p>\n<ul>\n<li><code class=\"language-text\">flock -w 5 200</code>：在文件描述符 200 上获取排他锁，等待最多 5 秒</li>\n<li><code class=\"language-text\">200&gt;&quot;${STATE_FILE}.lock&quot;</code>：锁文件与 state 文件分开（<code class=\"language-text\">.lock</code> 后缀）</li>\n<li><code class=\"language-text\">jq ... &gt; $tmp &amp;&amp; mv $tmp</code>：先写临时文件再原子替换，避免写到一半崩溃导致文件损坏</li>\n<li>超时不报错（<code class=\"language-text\">return 0</code>）——宁可丢失一次状态写入，也不阻塞整个 Hook 链</li>\n</ul>\n<h4><code class=\"language-text\">pending/</code> → <code class=\"language-text\">claimed/</code>：原子所有权转移</h4>\n<p><code class=\"language-text\">SubagentStart</code> 事件只提供 <code class=\"language-text\">agent_id</code> 和 <code class=\"language-text\">agent_type</code>，<strong>不提供 Team Lead 给 Sub-Agent 起的名字</strong>。但 session 需要用名字命名（这样 Sub-Agent 才能通过名字找到自己的 session 文件）。</p>\n<p>解决方案是两个 Hook 的接力：</p>\n<ol>\n<li><code class=\"language-text\">PreToolUse:Task</code>（Team Lead 上下文）能从 <code class=\"language-text\">tool_input</code> 中拿到 <code class=\"language-text\">name</code> 参数，写入 <code class=\"language-text\">pending/&lt;name&gt;</code> 文件</li>\n<li><code class=\"language-text\">SubagentStart</code>（仍是 Team Lead 上下文，但并发执行）通过 <code class=\"language-text\">mv pending/&lt;name&gt; claimed/&lt;agent_id&gt;</code> 原子认领</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">时间线：\n  T1  PreToolUse:Task 触发 → 写 .chorus/pending/frontend-worker\n  T2  PreToolUse:Task 触发 → 写 .chorus/pending/backend-worker\n  T3  SubagentStart(agent_id=a0e) 触发 → mv pending/frontend-worker → claimed/a0e ✓\n  T4  SubagentStart(agent_id=b1f) 触发 → mv pending/backend-worker → claimed/b1f ✓\n  T4&#39; SubagentStart(agent_id=c2g) 触发 → mv pending/frontend-worker → 失败（已被 a0e 认领）\n                                        → mv pending/backend-worker → 失败（已被 b1f 认领）\n                                        → 没有更多 pending 文件 → 跳过（内部 agent，不创建 session）</code></pre></div>\n<p><code class=\"language-text\">mv</code> 在同一文件系统上是原子操作——只有一个进程能成功移动同一个文件。这比 flock 更轻量，适合\"谁先到谁拿\"的场景。</p>\n<h4><code class=\"language-text\">sessions/</code> — Sub-Agent 的信息入口</h4>\n<p>这是对 Sub-Agent 唯一可见的部分。每个 session file 既是数据（sessionUuid），也是指令（workflow PE）。文件名就是 agent name——Sub-Agent 只需 <code class=\"language-text\">Read .chorus/sessions/&lt;my-name&gt;.json</code> 就能获得一切。</p>\n<h4>生命周期：创建到清理</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SessionStart  → mkdir -p .chorus/（如果不存在）\nPreToolUse    → 写 .chorus/pending/&lt;name&gt;\nSubagentStart → mv pending → claimed，写 sessions/&lt;name&gt;.json，更新 state.json\nTeammateIdle  → 读 state.json（查 session_uuid），无写入\nTaskCompleted → 读 state.json（查 session_uuid），无写入\nSubagentStop  → 删 sessions/&lt;name&gt;.json，删 claimed/&lt;agent_id&gt;，清 state.json 条目\nSessionEnd    → 如果 sessions/ 为空且 state.json 为空 → rm -rf .chorus/</code></pre></div>\n<p>整个目录的生命周期和 Claude Code session 一致——开始时创建，结束时清理，不留痕迹。</p>\n<h3>5.3 核心难题：Sub-Agent 的上下文注入</h3>\n<p>前面提到，所有 Hook 的输出都只注入到 Team Lead 的上下文中。那么，如何让 Sub-Agent 也能获得必要的信息？</p>\n<p>Chorus 插件的答案是：<strong>利用共享文件系统作为信息传递通道</strong>。</p>\n<p>Sub-Agent 虽然和 Team Lead 不共享上下文窗口，但它们共享同一个文件系统。而 Team Lead 的 spawn prompt 里一定会告诉 Sub-Agent 去读某个文件——这个文件就成了上下文注入的天然入口。</p>\n<h4>实现：Session file 内嵌 workflow PE</h4>\n<p><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-subagent-start.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">SubagentStart</code> Hook</a> 在写 session file 时，除了 sessionUuid 等数据字段外，额外写入一个 <code class=\"language-text\">workflow</code> 数组——包含完整的 5 步工作流指令，且每个 MCP 调用示例中的 sessionUuid 都是<strong>真实值</strong>（Bash heredoc 在写文件时展开变量）：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># on-subagent-start.sh 核心片段</span>\n<span class=\"token function\">cat</span> <span class=\"token operator\">></span> <span class=\"token string\">\"<span class=\"token variable\">${SESSIONS_DIR}</span>/<span class=\"token variable\">${SESSION_NAME}</span>.json\"</span> <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">SESSIONEOF\n{\n  \"sessionUuid\": \"<span class=\"token variable\">${SESSION_UUID}</span>\",\n  \"agentName\": \"<span class=\"token variable\">${SESSION_NAME}</span>\",\n  \"workflow\": [\n    \"=== Chorus Workflow — FOLLOW THESE STEPS ===\",\n    \"Your Chorus session UUID is: <span class=\"token variable\">${SESSION_UUID}</span>\",\n    \"\",\n    \"1. Check in: chorus_session_checkin_task({ sessionUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">${SESSION_UUID}</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, taskUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&lt;TASK_UUID><span class=\"token entity\" title=\"\\&quot;\">\\\"</span> })\",\n    \"2. Start:    chorus_update_task({ taskUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&lt;TASK_UUID><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, status: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>in_progress<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, sessionUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">${SESSION_UUID}</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span> })\",\n    \"3. Report:   chorus_report_work({ taskUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&lt;TASK_UUID><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, report: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>...<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, sessionUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">${SESSION_UUID}</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span> })\",\n    \"4. Checkout:  chorus_session_checkout_task({ sessionUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span><span class=\"token variable\">${SESSION_UUID}</span><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, taskUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&lt;TASK_UUID><span class=\"token entity\" title=\"\\&quot;\">\\\"</span> })\",\n    \"5. Submit:   chorus_submit_for_verify({ taskUuid: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>&lt;TASK_UUID><span class=\"token entity\" title=\"\\&quot;\">\\\"</span>, summary: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>...<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> })\",\n    \"\",\n    \"Replace &lt;TASK_UUID> with the actual Chorus task UUID provided in your prompt.\"\n  ]\n}\nSESSIONEOF</span></code></pre></div>\n<p>Sub-Agent 读取这个文件后，得到了数据（sessionUuid）和指令（workflow）。它只需要把 <code class=\"language-text\">&lt;TASK_UUID&gt;</code> 替换为 Team Lead 在 prompt 中给的值，就能直接按步骤执行。</p>\n<p>这样 Team Lead 的 spawn prompt 只需要：</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Task<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"frontend-worker\"</span><span class=\"token punctuation\">,</span>\n  prompt<span class=\"token punctuation\">:</span> <span class=\"token triple-quoted-string string\">\"\"\"\n    Your Chorus task UUID: task-A-uuid\n    Read .chorus/sessions/frontend-worker.json and follow the workflow inside.\n    Then implement the frontend user form component...\n  \"\"\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Bash heredoc 中的 <code class=\"language-text\">${SESSION_UUID}</code> 会在文件写入时被展开为真实值。</p>\n<h3>5.4 Session 复用：避免重复创建</h3>\n<p>当 Team Lead 多次 spawn 同名的 Sub-Agent 时（比如 Task 被 Admin reopen 后重新分配），插件不会创建新 Session，而是复用已有的：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># on-subagent-start.sh 中的复用逻辑</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$MATCH_STATUS</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"active\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token assign-left variable\">SESSION_UUID</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token variable\">$MATCH_UUID</span>\"</span>         <span class=\"token comment\"># 直接复用</span>\n    <span class=\"token assign-left variable\">SESSION_ACTION</span><span class=\"token operator\">=</span><span class=\"token string\">\"reused\"</span>\n<span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$MATCH_STATUS</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"closed\"</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$MATCH_STATUS</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"inactive\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token comment\"># 重开已关闭的 session</span>\n    chorus_reopen_session<span class=\"token punctuation\">(</span>sessionUuid<span class=\"token punctuation\">)</span>\n    <span class=\"token assign-left variable\">SESSION_ACTION</span><span class=\"token operator\">=</span><span class=\"token string\">\"reopened\"</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token comment\"># 创建新 session</span>\n    chorus_create_session<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n    <span class=\"token assign-left variable\">SESSION_ACTION</span><span class=\"token operator\">=</span><span class=\"token string\">\"created\"</span>\n<span class=\"token keyword\">fi</span></code></pre></div>\n<h3>5.5 自动清理：SubagentStop</h3>\n<p>当 Sub-Agent 退出时，<a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-subagent-stop.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">on-subagent-stop.sh</code></a>（异步执行）负责清理：</p>\n<ol>\n<li>查询 Session 的所有活跃 checkin，逐一 checkout</li>\n<li>关闭 Chorus Session</li>\n<li>删除本地状态（state entries、session file、claimed file）</li>\n<li>查询项目中新解除阻塞的 Task，通知 Team Lead</li>\n</ol>\n<p>这样即使 Sub-Agent 忘了 checkout 或 close session，插件也会兜底。</p>\n<h3>5.6 自动心跳：TeammateIdle</h3>\n<p>Sub-Agent 在两轮对话之间会进入 idle 状态，此时 <code class=\"language-text\">TeammateIdle</code> Hook 自动发送 heartbeat：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># on-teammate-idle.sh</span>\n<span class=\"token string\">\"<span class=\"token variable\">$API</span>\"</span> mcp-tool <span class=\"token string\">\"chorus_session_heartbeat\"</span> <span class=\"token punctuation\">\\</span>\n  <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">printf</span> <span class=\"token string\">'{\"sessionUuid\":\"%s\"}'</span> <span class=\"token string\">\"<span class=\"token variable\">$SESSION_UUID</span>\"</span><span class=\"token variable\">)</span></span>\"</span></code></pre></div>\n<p>输出被 <code class=\"language-text\">suppressOutput: true</code> 静默——心跳太频繁，不需要通知 Team Lead。</p>\n<hr>\n<h2>六、设计模式总结</h2>\n<p>从 Chorus 插件的实践中，可以提炼出几个通用的设计模式：</p>\n<h3>模式 1：文件系统作为 Sub-Agent 通信通道</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hook 写文件  →  Sub-Agent 读文件\n（Team Lead 上下文）    （Sub-Agent 上下文）</code></pre></div>\n<p>这是目前向 Sub-Agent 注入上下文的唯一可靠方式。适用于任何需要在 spawn 时传递动态信息给 Sub-Agent 的场景。</p>\n<h3>模式 2：PE 注入到数据文件中</h3>\n<p>不要把数据和指令分开——直接把工作流指令放在 Sub-Agent 必读的数据文件里。Sub-Agent 读取数据的同时就获得了操作指南。</p>\n<h3>模式 3：PreToolUse 捕获 + SubagentStart 执行</h3>\n<p><code class=\"language-text\">SubagentStart</code> 事件中拿不到 Sub-Agent 的名字（只有 <code class=\"language-text\">agent_id</code> 和 <code class=\"language-text\">agent_type</code>），但 <code class=\"language-text\">PreToolUse:Task</code> 可以从 <code class=\"language-text\">tool_input</code> 中提取。两个 Hook 通过文件系统（pending → claimed）传递信息。</p>\n<h3>模式 4：异步 Hook 做非阻塞清理</h3>\n<p>Session 关闭、资源清理、通知发送等不影响流程的操作，放在异步 Hook 中执行。不要让清理逻辑阻塞 Sub-Agent 的退出。</p>\n<h3>模式 5：Hook 只提醒，不强制</h3>\n<p><code class=\"language-text\">PreToolUse:Task</code> 向 Team Lead 注入提醒（\"记得在 prompt 里包含 task UUID\"），但不阻断操作。团队协作中，<strong>建议优于强制</strong>——过于严格的 Hook 会降低使用体验。</p>\n<hr>\n<h2>七、快速开始：编写你自己的插件</h2>\n<p>如果你想为自己的工具链编写 Claude Code 插件，这里是最小可行步骤：</p>\n<h3>Step 1：创建目录结构</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p my-plugin/.claude-plugin my-plugin/hooks my-plugin/bin</code></pre></div>\n<h3>Step 2：编写 plugin.json</h3>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-plugin\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"description\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"My custom plugin for Claude Code\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.1.0\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Step 3：编写第一个 Hook</h3>\n<p><code class=\"language-text\">hooks/hooks.json</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"SessionStart\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"matcher\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"startup\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"command\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"command\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${CLAUDE_PLUGIN_ROOT}/bin/on-start.sh\"</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">bin/on-start.sh</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/env bash</span>\n<span class=\"token builtin class-name\">set</span> -euo pipefail\n\n<span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span><span class=\"token string\">EOF\n{\n  \"systemMessage\": \"My plugin is active!\",\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"My Plugin is connected. Custom workflow instructions here.\"\n  }\n}\nEOF</span></code></pre></div>\n<h3>Step 4：本地测试</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x my-plugin/bin/on-start.sh\nclaude --plugin-dir ./my-plugin</code></pre></div>\n<h3>Step 5：发布到 Marketplace</h3>\n<p>创建 <code class=\"language-text\">.claude-plugin/marketplace.json</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-marketplace\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"owner\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Your Name\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"my-plugin\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"source\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./my-plugin\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.1.0\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2>写在最后</h2>\n<p>Claude Code 的插件系统提供了一套完整的扩展机制——从 Marketplace 分发，到 MCP 工具集成，到 Hooks 生命周期管理，再到 Skills 知识注入。Agent Teams（Swarm 模式）的引入让多 Agent 协作成为可能，而插件让这种协作变得可管理、可观测。</p>\n<p>Chorus 插件的实践表明，即使面对\"Hook 输出无法直接注入 Sub-Agent prompt\"这样的限制，通过巧妙利用共享文件系统和 PE 注入技术，仍然可以实现优雅的自动化工作流。</p>\n<p>如果你对 Chorus 感兴趣，欢迎访问 <a href=\"https://github.com/Chorus-AIDLC/chorus\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub</a> 了解更多。如果你正在构建自己的 Claude Code 插件，希望本文的经验能帮你少走弯路。</p>","excerpt":"本文基于 Chorus 项目的实际开发经验，系统介绍 Claude Code 的插件机制，重点探讨如何为 Agent Teams（Swarm 模式）构建插件，以及如何解决多 Agent 协作中的上下文注入难题。 TL;DR：这篇文章要聊什么 Claude Code 的 Agent Teams（也叫 Swarm 模式）让一个 Team Lead Agent 可以并行调度多个 Sub-Agent 协同工作。这是一个强大的能力——但随之而来的问题是：当你有一个外部工作追踪系统时，怎样让每个 Sub…","frontmatter":{"date":"February 21, 2025","path":"/building-claude-code-plugin-for-agent-teams-zh","title":"为 Claude Code Agent Teams 编写插件：从 Chorus 的实践经验看插件设计模式"}}},"pageContext":{}},"staticQueryHashes":["2560569871","3584596544","63159454"],"slicesMap":{}}