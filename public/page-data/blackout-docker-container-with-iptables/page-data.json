{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blackout-docker-container-with-iptables","result":{"data":{"markdownRemark":{"html":"<p>当我们把应用部署在<code class=\"language-text\">Kubernetes</code>集群中的时候可以很方便地使用例如<a href=\"https://istio.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Istio</a>的<code class=\"language-text\">Service Mesh</code>工具控制集群中的流量，例如熔断，灰度部署，蓝绿部署等功能。虽然当我们的集群部署在docker容器中但又没有Kubernetes环境时<code class=\"language-text\">Envoy</code>和<code class=\"language-text\">Istio</code>等工具仍然可以用来帮助控制集群流量，但是简单的服务熔断/下线等操作可以借助<code class=\"language-text\">Iptables</code>工具快速地实现，而不用侵入应用代码或者部署额外的架构。</p>\n<h1>TL;DR</h1>\n<p>假设我们部署一个简单的docker容器服务<a href=\"https://hub.docker.com/_/memcached\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Memcahced</a>, 将服务暴露的<code class=\"language-text\">11211</code>端口转发至本地的<code class=\"language-text\">11211</code>端口</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run memcached:latest -n memcached -p <span class=\"token number\">11211</span>:11211</code></pre></div>\n<p>容器memcached的docker子网ip地址为<code class=\"language-text\">172.17.0.5</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker inspect --format<span class=\"token operator\">=</span><span class=\"token string\">'{{.NetworkSettings.IPAddress}}'</span> memcached <span class=\"token comment\">#172.17.0.5</span></code></pre></div>\n<p>此时假设本机公网ip为<code class=\"language-text\">10.120.0.1</code>，那么我们向公网暴露了Memcahced服务<code class=\"language-text\">10.120.0.1:11211</code>，而在计算机本地访问Memcahced服务的地址则为<code class=\"language-text\">127.0.0.1:11211</code>。为了将Memcahced向公网和本地暴露的服务全部切断，我们需要使用如下iptables规则</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> iptables -I DOCKER-<span class=\"token environment constant\">USER</span> -d <span class=\"token number\">172.17</span>.0.5 -j REJECT <span class=\"token comment\"># 阻断公网向容器发送流量</span>\n<span class=\"token function\">sudo</span> iptables -I OUTPUT -d <span class=\"token number\">172.17</span>.0.5 -j REJECT <span class=\"token comment\"># 阻断本地向容器发送流量</span></code></pre></div>\n<p>按照<a href=\"https://docs.docker.com/network/iptables/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker and iptables</a>官网的示例，阻断外部流量使用第一条规则就能生效，但为什么阻断本地流量需要使用filter表的<code class=\"language-text\">OUTPUT</code>chain呢？背后的原理可能比你想象的要复杂。</p>\n<h1>Docker and iptable</h1>\n<p>关于Iptables的工作原理和结构这边不再赘述，如果不了解的话可以移步<a href=\"http://cn.linux.vbird.org/linux_server/0250simple_firewall.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">鸟哥的Linux私房菜</a>的这个章节学习。这里借用一下鸟哥的结构图进行说明(下图去除了mangle表)\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 494px; '>\n      <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.714285714285715%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAHXdgmYsIf/xAAaEAACAgMAAAAAAAAAAAAAAAAAAhExARJC/9oACAEBAAEFAsVKzoJXR//EABcRAQADAAAAAAAAAAAAAAAAAAABERL/2gAIAQMBAT8BpiH/xAAXEQEAAwAAAAAAAAAAAAAAAAAAARES/9oACAECAQE/AaYh/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAEgIjNhkaH/2gAIAQEABj8CoXTJaW4f/8QAHBAAAQMFAAAAAAAAAAAAAAAAAQAQESExUWFx/9oACAEBAAE/IQApTmEtCeZYtL//2gAMAwEAAgADAAAAEBzf/8QAGREBAAIDAAAAAAAAAAAAAAAAAQARMdHw/9oACAEDAQE/EBGGdUan/8QAGREAAgMBAAAAAAAAAAAAAAAAAAEhMdHw/9oACAECAQE/EEyo4jD/xAAfEAEAAgIABwAAAAAAAAAAAAABABEhMRBBUWFxofD/2gAIAQEAAT8Q3F3kD1MAwis1+Iu8p87QBYBe6I6FGunD/9k='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='iptables' title='iptables' src='/static/9197ba71757a9ca73e9d189f3ac8387d/ea737/iptables.jpg' srcset='/static/9197ba71757a9ca73e9d189f3ac8387d/e52aa/iptables.jpg 175w,\n/static/9197ba71757a9ca73e9d189f3ac8387d/70ebb/iptables.jpg 350w,\n/static/9197ba71757a9ca73e9d189f3ac8387d/ea737/iptables.jpg 494w' sizes='(max-width: 494px) 100vw, 494px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n    </span></p>\n<p>那docker对iptables进行了哪些修改呢？在拉起memcached服务之后我们可以在机器上运行<code class=\"language-text\">iptables -L -nv</code>进行详细查看。</p>\n<h2>从外部请求服务</h2>\n<p>我们知道menmcached协议是基于http/1.1的。假设我们在外部的某台机器上发起了<code class=\"language-text\">curl 10.120.0.1:11211</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># curl 10.120.0.1:11211</span>\ncurl: <span class=\"token punctuation\">(</span><span class=\"token number\">52</span><span class=\"token punctuation\">)</span> Empty reply from server</code></pre></div>\n<p>那这个请求在iptable中走过了怎样的一个流程呢？</p>\n<p>按照Iptables的顺序，我们先查看<code class=\"language-text\">PREROUTING</code> chain</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># sudo iptables -t nat -nv -L PREROUTING</span>\nChain PREROUTING <span class=\"token punctuation\">(</span>policy ACCEPT 1449K packets, 106M bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n  24M 1282M DOCKER     all  --  *      *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0            ADDRTYPE match dst-type LOCAL</code></pre></div>\n<p>这里docker添加的规则非常简单。对于外部请求本地的流量转由<code class=\"language-text\">Docker</code> chain处理。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># sudo iptables -t nat -nv -L DOCKER</span>\nChain DOCKER <span class=\"token punctuation\">(</span><span class=\"token number\">2</span> references<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n<span class=\"token number\">20626</span> 1670K RETURN     all  --  docker0 *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0           \n<span class=\"token number\">32712</span> 1772K DNAT       tcp  --  <span class=\"token operator\">!</span>docker0 *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0            tcp dpt:11211 to:172.17.0.5:11211</code></pre></div>\n<p>在NAT表上的Docker链也非常简单，一共有两条规则：</p>\n<ul>\n<li>所有input interface设备为<code class=\"language-text\">docker0</code>，也就是发往docker网络内部的流量直接返回，不进行进一步判断</li>\n<li>所有不发网docker网络的流量，如果是<code class=\"language-text\">tcp</code>连接并且端口为11211的，DNAT转发至<code class=\"language-text\">172.17.0.5:11211</code>，也就是memcached的容器内部。</li>\n</ul>\n<p>值得注意的是这和<code class=\"language-text\">DOCKER</code> chain有两个references。除了<code class=\"language-text\">PREROUTING</code> chain之外，<code class=\"language-text\">OUTPUT</code> chain也使用了这条自定义chain。我们下面再讨论这条链。</p>\n<p>很明显经过<code class=\"language-text\">PREROUTING</code>之后我们的请求被DNAT到了172.17.0.5:11211，那么下一步就应该由<code class=\"language-text\">filter</code>表的<code class=\"language-text\">FORWARD</code> chain过滤请求了。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"> <span class=\"token comment\"># sudo iptables -nv -L FORWARD</span>\nChain FORWARD <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">0</span> packets, <span class=\"token number\">0</span> bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n 237M   23G DOCKER-<span class=\"token environment constant\">USER</span>  all  --  *      *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0           \n 237M   23G DOCKER-ISOLATION-STAGE-1  all  --  *      *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0           \n 102M 9905M ACCEPT     all  --  *      docker0  <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0            ctstate RELATED,ESTABLISHED\n  23M 1252M DOCKER     all  --  *      docker0  <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0           \n 111M   12G ACCEPT     all  --  docker0 <span class=\"token operator\">!</span>docker0  <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0           \n    <span class=\"token number\">1</span>    <span class=\"token number\">52</span> ACCEPT     all  --  docker0 docker0  <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">0.0</span>.0.0/0   </code></pre></div>\n<p>可以看到这里的规则就比较多了，但是我们只需要关心其中几条就可以了</p>\n<ul>\n<li>DOCKER-USER: 所有的请求都会先交给这条链处理，这也是Docker 18.x新增的链，专门用于给用户扩展自定义的请求过滤规则</li>\n<li>DOCKER-ISOLATION-STAGE-1: Docker本身的网络隔离相关，这里不深究</li>\n<li>DOCKER: Docker自身对流量的控制，这里不深究</li>\n</ul>\n<p>而我们最终的规则之一就是按照Docker官方的建议加到了<code class=\"language-text\">DOCKER-USER</code>链中。</p>\n<p>最后在<code class=\"language-text\">POSTROUTING</code>链中主要是一些SNAT的规则，与我们这次讨论的服务熔断无关。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># sudo iptables -t nat -nv -L POSTROUTING</span>\nChain POSTROUTING <span class=\"token punctuation\">(</span>policy ACCEPT 6566K packets, 349M bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n8226K  584M MASQUERADE  all  --  *      <span class=\"token operator\">!</span>docker0  <span class=\"token number\">172.17</span>.0.0/16        <span class=\"token number\">0.0</span>.0.0/0           \n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> MASQUERADE  tcp  --  *      *       <span class=\"token number\">172.17</span>.0.5           <span class=\"token number\">172.17</span>.0.5           tcp dpt:11211</code></pre></div>\n<p>那么我们想熔断对外部暴露的服务，只需要增加规则</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> iptables -I DOCKER-<span class=\"token environment constant\">USER</span> -d <span class=\"token number\">172.17</span>.0.5 -j REJECT</code></pre></div>\n<p>这样的话在<code class=\"language-text\">FORWARD</code>链中就能正确过滤请求了。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"> <span class=\"token comment\"># curl 10.120.0.1:11211</span>\ncurl: <span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span> Failed to connect to <span class=\"token number\">10.120</span>.0.1 <span class=\"token number\">11211</span>: Connection refused</code></pre></div>\n<p>那我们成功得完全将该服务熔断了吗？并不是。如果本地跑了其他服务想请求memached的服务，似乎熔断并没有生效。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"> <span class=\"token comment\"># curl localhost:11211</span>\ncurl: <span class=\"token punctuation\">(</span><span class=\"token number\">52</span><span class=\"token punctuation\">)</span> Empty reply from server</code></pre></div>\n<h2>从本地请求服务</h2>\n<p>本地发起的服务<code class=\"language-text\">curl localhost:11211</code>最先进入的iptable chain是<code class=\"language-text\">nat</code>表的<code class=\"language-text\">OUTPUT</code>链</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># sudo iptables -t nat -nv -L OUTPUT</span>\nChain OUTPUT <span class=\"token punctuation\">(</span>policy ACCEPT 2669K packets, 139M bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n3305K  172M DOCKER     all  --  *      *       <span class=\"token number\">0.0</span>.0.0/0           <span class=\"token operator\">!</span><span class=\"token number\">127.0</span>.0.0/8          ADDRTYPE match dst-type LOCAL</code></pre></div>\n<p>像上文所说，这里的<code class=\"language-text\">OUTPUT</code>链也引用了<code class=\"language-text\">DOCKER</code>链做DNAT转发。</p>\n<p><strong>等等，好像有哪里不太对劲。</strong>这条规则对于请求的<code class=\"language-text\">destination</code>的要求是<code class=\"language-text\">!127.0.0.0/8</code>。我们知道<code class=\"language-text\">localhost</code>的destination是<code class=\"language-text\">127.0.0.1</code>，不符合这条规则的要求，我们的请求并没有被DOCKER链处理。实际上对本地的请求分为两种，一种是直接请求<code class=\"language-text\">127.0.0.1</code>，另一种是请求自身的公网ip<code class=\"language-text\">10.120.0.1</code>。显然第二种情况就会被这个<code class=\"language-text\">OUTPUT</code>链上的规则匹配，进而进行DNAT。但是对于直接对<code class=\"language-text\">localhost</code>的请求，并没什么特殊的处理。</p>\n<h3>对localhost的请求</h3>\n<p>我们先讨论第一种情况，对于<code class=\"language-text\">localhost</code>的请求没有被<code class=\"language-text\">NAT OUTPUT</code>链处理，而<code class=\"language-text\">FILTER OUTPUT</code>链docker也没有进行修改，最后保持<code class=\"language-text\">localhost:11211</code>这个状态就走出了<code class=\"language-text\">POSTROUTING</code>链。</p>\n<p>然而这个请求是针对本地的，还会从本地的iptables入口进入一次。<strong>并且这种对本地的请求不会经过PREROUTING链</strong>，就导致了最终进入了<code class=\"language-text\">INPUT</code>链进行处理。同样的，Docker也没有对该链进行修改。</p>\n<p>随后我们的这条请求就被监听本地<code class=\"language-text\">11211</code>端口的程序处理了(换句话说，其他情况下根本不会走到本地监听端口，而是直接在iptables中被DNAT了)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># sudo lsof -i:11211</span>\ndocker-pr <span class=\"token number\">4714</span> root    4u  IPv6     <span class=\"token number\">37763</span>      0t0  TCP *:memcache <span class=\"token punctuation\">(</span>LISTEN<span class=\"token punctuation\">)</span></code></pre></div>\n<p>可以看到这里被一个叫docker-pr的进程监听了，也就是<code class=\"language-text\">docker-proxy</code>。他将请求代理转发到了对应的容器端口，也就是<code class=\"language-text\">172.17.0.5:11211</code>。经过转发之后的流量再走过一遍<code class=\"language-text\">NAT OUTPUT</code>, <code class=\"language-text\">FILTER OUTPUT</code>和<code class=\"language-text\">POSTROUTING</code>链后，被容器接收。</p>\n<h3>对公网ip的请求</h3>\n<p>与对<code class=\"language-text\">localhost</code>的请求不用，直接访问自身公网ip的请求被<code class=\"language-text\">NAT OUTPUT</code>定向到<code class=\"language-text\">NAT DOCKER</code>链进行DNAT转换，直接从<code class=\"language-text\">10.120.0.1:11211</code>被转发到了<code class=\"language-text\">172.17.0.5:11211</code>。经由<code class=\"language-text\">FILTER OUTPUT</code>和<code class=\"language-text\">POSTROUTING</code>发送到了容器内部，并没有进入到本地监听的<code class=\"language-text\">11211</code>端口中。</p>\n<p>总结一下两种本地请求的iptables链路：</p>\n<ul>\n<li>localhost: OUTPUT(N) -> OUTPUT(F) -> POSTROUTING -> INPUT -> docker-proxy -> OUTPUT(N) -> OUTPUT(F) -> POSTROUTING -> container</li>\n<li>10.120.0.1: OUTPUT(N) -> OUTPUT(F) -> POSTROUTING -> container</li>\n</ul>\n<p>显然<code class=\"language-text\">localhost</code>请求走两圈iptables，链路比公网ip长了一倍。而两者的链路中，都会走过的<code class=\"language-text\">Filter</code>表的部分是<code class=\"language-text\">OUTPUT</code>链，其中<code class=\"language-text\">localhost</code>请求走了两次，第一次的请求地址是<code class=\"language-text\">127.0.0.1:11211</code>而第二次的是<code class=\"language-text\">172.17.0.5:11211</code>。所以两种请求都会以为<code class=\"language-text\">172.17.0.5:11211</code>的身份走过一次<code class=\"language-text\">filter OUTPUT</code>链。所以我们最终决定把规则放在这个位置。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> iptables -I OUTPUT -d <span class=\"token number\">172.17</span>.0.5 -j REJECT\n<span class=\"token comment\"># curl -v localhost:11211</span>\n* Rebuilt URL to: localhost:11211/\n*   Trying <span class=\"token number\">127.0</span>.0.1<span class=\"token punctuation\">..</span>.\n* TCP_NODELAY <span class=\"token builtin class-name\">set</span>\n* Connected to localhost <span class=\"token punctuation\">(</span><span class=\"token number\">127.0</span>.0.1<span class=\"token punctuation\">)</span> port <span class=\"token number\">11211</span> <span class=\"token punctuation\">(</span><span class=\"token comment\">#0)</span>\n<span class=\"token operator\">></span> GET / HTTP/1.1\n<span class=\"token operator\">></span> Host: localhost:11211\n<span class=\"token operator\">></span> User-Agent: curl/7.58.0\n<span class=\"token operator\">></span> Accept: */*\n<span class=\"token operator\">></span> \n* Recv failure: Connection reset by peer\n* Closing connection <span class=\"token number\">0</span>\ncurl: <span class=\"token punctuation\">(</span><span class=\"token number\">56</span><span class=\"token punctuation\">)</span> Recv failure: Connection reset by peer\n <span class=\"token comment\"># curl -v 10.120.0.1:11211</span>\n* Rebuilt URL to: <span class=\"token number\">10.120</span>.0.1:11211/\n*   Trying <span class=\"token number\">10.120</span>.0.1<span class=\"token punctuation\">..</span>.\n* TCP_NODELAY <span class=\"token builtin class-name\">set</span>\n* connect to <span class=\"token number\">10.120</span>.0.1 port <span class=\"token number\">11211</span> failed: Connection refused\n* Failed to connect to <span class=\"token number\">10.120</span>.0.1 <span class=\"token number\">11211</span>: Connection refused\n* Closing connection <span class=\"token number\">0</span>\ncurl: <span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span> Failed to connect to <span class=\"token number\">10.120</span>.0.1 port <span class=\"token number\">11211</span>: Connection refused</code></pre></div>\n<p>可以看到两种请求都失败了，但是我们这次开启了<code class=\"language-text\">curl -v</code>查看详细的握手过程。可以看到对<code class=\"language-text\">localhost</code>的请求成功建立了tcp连接之后才失败。这是因为对于该请求而言，先与<code class=\"language-text\">docker-proxy</code>建立了连接，而<code class=\"language-text\">docker-proxy</code>代理的请求在走过第二次iptables的时候失败了。相比较下<code class=\"language-text\">10.120.0.1</code>的请求并没有建立tcp连接，是因为其在<code class=\"language-text\">nat OUTPUT</code>链中已经被DNAT转发到容器中了，所以并没有和<code class=\"language-text\">docker-proxy</code>建立连接。</p>\n<p>此时从外部访问memcahed请求并没有受到影响，因为外部的请求走的是<code class=\"language-text\">PREROUTING</code> -> <code class=\"language-text\">FORWARD</code> -> <code class=\"language-text\">POSTROUTING</code>链路，不经过<code class=\"language-text\">filter OUTPUT</code>链。</p>\n<h1>总结</h1>\n<p>综上所述，我们可以得出结论，如果想要对某个docker容器完全阻断从本地以及外部发送来的请求，我们需要至少两个iptables规则</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> iptables -I DOCKER-<span class=\"token environment constant\">USER</span> -d <span class=\"token operator\">&lt;</span>container_ip<span class=\"token operator\">></span> -j REJECT <span class=\"token comment\"># 阻断公网向容器发送流量</span>\n<span class=\"token function\">sudo</span> iptables -I OUTPUT -d <span class=\"token operator\">&lt;</span>container_ip<span class=\"token operator\">></span> -j REJECT <span class=\"token comment\"># 阻断本地向容器发送流量</span></code></pre></div>\n<p>同时我们也有一个有趣的发现：除了以<code class=\"language-text\">localhost</code>的方式向容器发送的流量外，其他形式的请求并不会走到监听了本地端口的<code class=\"language-text\">docker-pr</code>。在做trouble shooting的时候需要针对症状找对方向。</p>","excerpt":"当我们把应用部署在集群中的时候可以很方便地使用例如Istio的工具控制集群中的流量，例如熔断，灰度部署，蓝绿部署等功能。虽然当我们的集群部署在docker容器中但又没有Kubernetes环境时和等工具仍然可以用来帮助控制集群流量，但是简单的服务熔断/下线等操作可以借助工具快速地实现，而不用侵入应用代码或者部署额外的架构。 TL;DR 假设我们部署一个简单的docker容器服务Memcahced, 将服务暴露的端口转发至本地的端口 容器memcached的docker子网ip…","frontmatter":{"date":"April 22, 2020","path":"/blackout-docker-container-with-iptables","title":"使用iptables熔断docker container中的服务"}}},"pageContext":{}},"staticQueryHashes":["1176552510","3649515864","63159454","846684790"]}