{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/aws-athena-s3-data-lake-architecture","result":{"data":{"markdownRemark":{"html":"<p>机器学习和大数据分析技术在过去十年内高速发展，到今天已经成为了现代化的服务与应用不可或缺的一部分。而搭建一套数据湖系统则是开始将机器学习与数据分析带到项目中的第一步。在这几篇文章里，我们将会学习到如何使用<code>AWS Athena</code>服务与<code>S3</code>文件存储搭建一套完整的数据湖解决方案。</p>\n<h1>1. AWS的数据湖</h1>\n<p>在AWS的这篇<a href=\"https://aws.amazon.com/big-data/datalakes-and-analytics/what-is-a-data-lake/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">文章</a>中，阐述了<code>数据湖</code>与<code>数据仓库</code>的主要区别。简单地概括一下即：</p>\n<ul>\n<li>“数据仓库”一般指存储结构化业务数据的系统，数据的Schema在数据存储时就已经确定(<code>schema-on-write</code>)，这种系统经常用来做批量的业务数据分析以及可视化。比较典型的例子就是<a href=\"https://aws.amazon.com/redshift/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AWS Redshift</a>列式存储数据库，非常适合用来做业务的<code>OLAP</code>任务。</li>\n<li>“数据湖”则一般指不仅存储了业务上的关系型数据，还可以存储从移动设备，IoT设备或社交网络中获取的非关系型数据或指标数据(Metrics)，在储存到数据湖的时候并不指定数据的Schema，而仅在数据被读取的时候使用某种Schema去序列化数据湖中的数据(<code>schema-on-read</code>)，或者衔接使用<code>ETL</code>(Extract, transform, load)任务来清洗，分类数据。这样就大大降低了数据采集和存储端的复杂度，并最大限度地保留了数据的灵活性。比如同一份数据，即可以通过Athena使用SQL以及一个固定的Schema读取，也可以通过AWS Glue ETL Job转化成其他的数据结构。</li>\n</ul>\n<p>从上面的描述可以看出，数据湖是一系列数据服务的中心。而从架构上，AWS数据湖是这样的:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/690142f2a18f836711b8789b2756a000/f0685/data-lake-arch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACiElEQVR42pVTW2vUUBDOD/NN7EPxzb/gS72hQlHQvgmCtQ8iRcVSECpirYKC2Iuibb3Wai9Ut83SdtvuJclmszk5Jzn3E2dj3Wa1Sh3CYU4y38z3zUys9E8zJu+b7MoEvTU9MPj6ulQCrtq0oqx9kFrv4uFUKjVaKUMo6Rk62TN0SmTgnzn/Am5b5kup4Cw7btlxfobwBFLmwRk/Mj0bXuzjn+YgnHz46J84w6deQYI4omP9ztOBEAJLBXK3d+freGLli9A0dR4+tg93o4kpSNQYn7S7joYPHklIhJKB04uD520ItJeCq8cX3j/zO2gzIZMQ1YvrCUJwjYKmPb/Q9OqUAzytVr1KxQOHc+HUAoyTDjBl3OzT/VY0ZWJkbOX2yFJCZXsgFigFDIqwzhwtBbyPv882bnbz5bFWjBIARhG90j9z7vJkhHnWQq21sUgcO27dXt/EJG5Vhrmkabj4pnjpEP48mjVSQ1lMyMZmZXWtxBhrM7LCEAXNJiAZgwISiAAFFIbFlWXf83blcB4TPjnsz9wnWu7JsYQQftAE2krBRLRTohPD9XJBtFZIaxX5nLGY0rqLbpxdutNrc6oyOhm4vRqmtQ567qV7oWtlZjRQqYgxwfY8DhpRTEFdYaMMj5R7pS0uRIiiCBPKGGSoO/jJyJfqVgTf4piWtsvNECWMCybY22/iXSE1HbRlzfUcz0soBeZCiopbZpz9WmBImFIp4wCtHemrHLtmmNyjDZ9Bs+v5ILA9QNM5bi4VQXh1+PnavRec0t81/9sorJgyhlFFcD7tgcDQF+gm2tyOtnbyxA4Ehl8Swo1Qu4L/q7JSiiuF7J3GYlHn2n0gMBjsUq1WrVQr+Tn/AIEaawOYHnCvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"data-lake-arch\"\n        title=\"\"\n        src=\"/static/690142f2a18f836711b8789b2756a000/8c557/data-lake-arch.png\"\n        srcset=\"/static/690142f2a18f836711b8789b2756a000/4edbd/data-lake-arch.png 175w,\n/static/690142f2a18f836711b8789b2756a000/13ae7/data-lake-arch.png 350w,\n/static/690142f2a18f836711b8789b2756a000/8c557/data-lake-arch.png 700w,\n/static/690142f2a18f836711b8789b2756a000/f0685/data-lake-arch.png 835w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>在图中，整个数据湖及其下游架构包含了相当多的服务，而我们这次只需要了解构成数据湖的最基本服务:</p>\n<ul>\n<li>AWS S3: 文件存储系统，S3之于数据湖就好像<code>HDFS</code>之于<code>Hadoop</code>。在AWS数据湖概念中，基本上S3是所有数据存放的地方，也就是“湖”这个概念本身。而将数据放入“湖”中，既可以简单地通过API将文件存储到S3桶中，也可以使用<code>Glue</code>从各个源头通过写入<code>Data catalog</code>的方式，最终存入S3中。</li>\n<li>AWS Athena: 在有了“湖”后，下一个需要解决的问题是如何从湖中获取数据。Athena基于<a href=\"https://trino.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Trino/Presto</a>引擎和<a href=\"https://spark.apache.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Apache Spark</a>框架实现了通过SQL来查询数据湖中的数据。</li>\n<li>AWS Glue: 包含在Glue中的服务非常多，而其中最关键的部分是<code>Data catalog</code>。如上文所提到的，数据湖是一个Schema-on-read系统，而AWS Glue Data Catalog就扮演了这个\"Schema\"的角色，同时也将抽象的<code>Table</code>与实际储存在S3中的文件关联了起来。当使用Athena查询数据时，需要选择数据所属的<code>Table</code>，即定义在Glue中的Schema，将类似JSON文件的无Schema数据序列化后读取出来。而从各个数据源头读取数据并存入S3的时候，也可以选择数据的目标<code>Table</code>，从而将数据的读写接口与数据实际储存的位置区分开来。这一层抽象使得<code>Data catalog</code>这个概念也对数据网格<code>Data Mesh</code>至关重要。关于<code>Data Mesh</code>的内容我们在之后的文章中再详细介绍。</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/53ecbc1902ce3792588177f4b736e87f/7eab7/athena-glue.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABEUlEQVR42m1Ry26DQAzk/z+tlx5yaKtGfZA2CpAEWBbY99SzQC7FkoVtxmN7tvAhIsaElBZnHGLcd+8QQli+a22aZ+hxgvcB5CqikDjv0fWDuBJQyMT/jMPUHan5RBobJMGxt+161NebEPqcZ0LrHHo1wBibN/CcLtNmEzHOEY5XCM4LTpcv8HaSwZILloS3eytYKxiQEJIYtH0vhGY5SQi5Y3lucXg9Sb4syU2eng+o6uYhEXs7pTKeQwoG02xw+j3jUjUPMtqlqvD2fnxIYK2F1hrG2rwx62rQeVDMmvLkuIBZ2Bo3wqq+4vjxnTXeM+r2Vf5kDE+nFW49Me68KjehNnzBsOqafcMw5uuu/8n1B3dKIzlSbeT8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"athena-glue\"\n        title=\"\"\n        src=\"/static/53ecbc1902ce3792588177f4b736e87f/8c557/athena-glue.png\"\n        srcset=\"/static/53ecbc1902ce3792588177f4b736e87f/4edbd/athena-glue.png 175w,\n/static/53ecbc1902ce3792588177f4b736e87f/13ae7/athena-glue.png 350w,\n/static/53ecbc1902ce3792588177f4b736e87f/8c557/athena-glue.png 700w,\n/static/53ecbc1902ce3792588177f4b736e87f/e996b/athena-glue.png 1050w,\n/static/53ecbc1902ce3792588177f4b736e87f/2cefc/athena-glue.png 1400w,\n/static/53ecbc1902ce3792588177f4b736e87f/7eab7/athena-glue.png 2360w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>接下来我们着重介绍一下Athena以及Glue。</p>\n<h1>2. AWS Athena</h1>\n<p>AWS Athena在整个流水线中中起到了数据访问接口的作用：\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d46958f71cb7723842d6e83cd6b75861/2dc7d/athena-arch.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.857142857142854%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAABYlAAAWJQFJUiTwAAABgElEQVR42oVSiVKDMBDl/3/OccaqKLUF2tJCoZy5s/iSYGt1HJdjwrL7jmwiY8lawlsba6y7bwv7K7MsUG+FUpFUapymiTHyMc+ze+6DvqWEkIxxLJQ2EToPx9OprJRUEKGNCaULFtEVNCSPZZUfCutUmAgwjLFhGEGO39BDRL+ZkUQD1lwI1C7MjIuu7yHG+jbXjGqtTbkzVWrq1LQ5OfsOcWJ8vcni5ANk8B8BCcqNjwAPfPJAlD1RFcNL+Idm9JTVuaqbtuudbDTXl0vbdti5IDso51Idsm2RvgsJWpf84cXJFlJiw9ab9Fw3SAHPkxIYkm2+TvfgcbP0ugABMgQ+/YZxXjeX4lhiXFAWzKFOa818wH6wg7fSGqBFWUqpnGel1KXtnGypwpBpvo5qpusC/UA0ZhxHbLAOzE3TPsfJS5xUXra9n+pt2D4DT6vXt4fHFaYDCxHGC827fdEP4/xXkL/mGYchzXabNO+Hwcm2XwfY+uP9z62NXQ654VJ9Ao069fDm6s76AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"athena-arch\"\n        title=\"\"\n        src=\"/static/d46958f71cb7723842d6e83cd6b75861/8c557/athena-arch.png\"\n        srcset=\"/static/d46958f71cb7723842d6e83cd6b75861/4edbd/athena-arch.png 175w,\n/static/d46958f71cb7723842d6e83cd6b75861/13ae7/athena-arch.png 350w,\n/static/d46958f71cb7723842d6e83cd6b75861/8c557/athena-arch.png 700w,\n/static/d46958f71cb7723842d6e83cd6b75861/e996b/athena-arch.png 1050w,\n/static/d46958f71cb7723842d6e83cd6b75861/2cefc/athena-arch.png 1400w,\n/static/d46958f71cb7723842d6e83cd6b75861/2dc7d/athena-arch.png 1760w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n对于类似于机器学习的下游任务来说，可通过Athena，从多种不同的入口获取序列化的数据。我们今天重点关注这些入口中的\"S3 data lake\"。</p>\n<p>为了完成这一工作，Athena需要提供两项基本的能力:</p>\n<ol>\n<li>提供一套统一的SQL接口，使得下游服务可以方便地获取数据，而不必担心底层的数据到底是如何储存的。</li>\n<li>解析SQL语句并转换为具体的任务，从底层数据存储中获取对应的数据并序列化</li>\n</ol>\n<p>为了解决这两个问题，Athena选择了<code>Trino/Presto</code>引擎。</p>\n<h2>2.1 Trino/Presto</h2>\n<p><code>Trino</code>是一个开源分布式的SQL查询引擎。如果要用一句话概括它的作用，那就是<code>SQL on Everything</code>。这也是Trino的前身<code>Presto</code>在发布时的论文标题: <a href=\"https://trino.io/Presto_SQL_on_Everything.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Presto: SQL on Everything</a></p>\n<p>Trino提供了<a href=\"https://blog.ansi.org/2018/10/sql-standard-iso-iec-9075-2016-ansi-x3-135/#gref\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ANSI SQL</a>接口并可以将其转换为下游任务，从而实现将SQL应用在各种各样的数据结构上。整个Presto的架构和流程如下图所示:\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.28571428571428%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAADq0lEQVR42o2TXWyTVRjHe2WiFyQm3JCIIQyYDEM0auZkMj8C4SMSYlBivJDgjVyhJkQZJhoV5ggJYgZiFieRTZQ51m2UsHZdu7abG+2+ALutb9euXdePtWvffr59O9ufZx/JLuTCk7z5P+e85/zP/3n+59FkMhkSiQRyMkl8PkJiLoDfNUXQLRH2+wj7Zgh5pgl5PSvocRPxz5BTFDKpBEUlQSmfXMZiQUHjdruxDw0yNiVhqz2JsbKM7t07MFRtw/jOHnrfP4i+cjP6V8oxLK2/vAXD4RrC81GSkRn8Dh1e+x1mBarx2RVCx70hxqVp+k+dwFJdjvVgFX2vbqd3CY/uxSJi8+4KrHtfpK9qC6Z9L4mM0hSzMSzaJjqbL2O61UhBDqDxTrsZttsZGx9n1GxkpKMV6+/XMTf/wmjPXUa6dYx2tjHYfpO71xq519HGiP4OubwKqsyEsQVDy/c4Db9STAXR/DSywJ4OmQO6NF+b/Bw3pThizHPo9gJHDSkOG3LUWiN82rfAm50yb+mzfNAjk1XyoCzQ3G3kslbPzzoDSlwoPG1Ls/7GP2xohXdbvexsU9jYBlvbYbu2yAYR728Nsb89RlmXWLsNz2nzZBShMBvl4+sGjl0zc7xJTzrmR+OK5miVZG5MRnkQTNPtSdExnaFr9WuXMoyFMhgnglwxT3Gp5yHN/ZMoeaGwqKKm5kXt/KgxSTidREOpRCzkF08mwKNHiZyqEo5GkSQXfo8knpCEHJojG4uSS8goQRdKbI6SKgiLJchkc6ImiuAurdGshulcngNX+ymrt7DpOxsn2u7j1P5Bb/UzmGp2YNy1jZ4XnsLy9usoCWHKioa1w039bq5YJC72unjgC6Omo7zWYKPigo3yeivHfnMw0tyIaVc55ppnsbyxk4GaCgYOVa8RLhYXKZBiKhRk41dGnq6z8sSZXup1o+KvSiCWZCaSYGY+QTSRIp2Uic/6SAYDBKYmMGhv4bBZRQ3jSzUEOStaT4kQFps/FAreaxpgX4OZPwed4rYkP5glanVOPuty0mL34h8e5GHdGZznv2T87Gmspz7CceEbCul5NIXCIh6v2DTrp6AWllP3iD5eakc5voCSzfB8nZHHheLHPu/hSONf2Bt/5O6mdei3rsdQ9iSmzevoqywXxvhWUv6Pr0J1cdWVwuIiVy0uzuknOds9yc1hL77hIf6+dI7JhvOMX/wWyxef4BBYyCuPJlwhLfF/xlIL3nd78YTCy/N/AeLm33xKh004AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"presto-arch\"\n        title=\"\"\n        src=\"/static/c94ff3c8a737a40142f4fa71cd89b1e9/8c557/presto-arch.png\"\n        srcset=\"/static/c94ff3c8a737a40142f4fa71cd89b1e9/4edbd/presto-arch.png 175w,\n/static/c94ff3c8a737a40142f4fa71cd89b1e9/13ae7/presto-arch.png 350w,\n/static/c94ff3c8a737a40142f4fa71cd89b1e9/8c557/presto-arch.png 700w,\n/static/c94ff3c8a737a40142f4fa71cd89b1e9/5b587/presto-arch.png 1010w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>一个query从SQL到任务的整个过程可以被描述为:</p>\n<ul>\n<li>系统通过HTTP接收到SQL命令</li>\n<li>解析SQL并生成和优化分布式执行计划</li>\n<li>系统将计划分配给worker</li>\n<li>Worker接到任务后开始从外部储存读取数据</li>\n<li>根据任务图，并行执行任务并将结果传递到执行下一阶段任务的worker，最终最后一个worker将结果返回</li>\n</ul>\n<p>为了实现在各种不同的数据存储上进行SQL查询，Presto在整个流程中设计了几个Connector API接口。通过调用这些接口，Presto就会在任务整个生命周期中的各个环节从外部Connector获取必要信息，或是通过外部系统操作底层数据。这些接口是：</p>\n<ul>\n<li>Metadata API: 获取数据的metadata，其主要包括当前查询数据的Schema。</li>\n<li>Data Location API: 获取数据的位置，比如实现S3的Connector时，需要返回某张表在S3的具体地址。</li>\n<li>Data Source API: 从外部系统读取数据页。</li>\n<li>Data Sink API: 写数据到外部系统。</li>\n</ul>\n<p>可以看得出，Athena通过为不同的数据源实现了这几个API给Trino提供了一个Connector，就可以完成上述任务。</p>\n<p>说一些题外话：<code>Trino/Presto</code>一开始是2012年左右在Facebook内部开始的项目。Presto的创始团队是开源文化的拥趸，并且将Presto也打造成了一个开源项目，并和Airbnb, Dropbox, Netflix等公司的工程师们一起改善Presto。但对于Facebook来说打造完全开源的产品并维护一个良好的开源社区显然不是第一要务，相信大家从臭名昭著的<a href=\"https://medium.com/@raulk/if-youre-a-startup-you-should-not-use-react-reflecting-on-the-bsd-patents-license-b049d4a67dd2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React BSD+Patent license</a>事件多少可以看得出Facebook的态度。虽然React的lisence最后还是改成了MIT，但Presto就没那么好运了。2018年Facebook开始收紧对Presto的约束并要求把代码的写权限开放给毫无经验的Facebook工程师们。五位创始人别无选择，只能离开Facebook并把Presto更名为Trino继续用开源社区的方式进行维护。更详细的故事可以看看Trino的<a href=\"https://trino.io/blog/2022/08/02/leaving-facebook-meta-best-for-trino.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这篇博客</a>。</p>\n<h1>3. AWS Glue</h1>\n<p>对于数据湖<code>Schema-on-read</code>的特性来说，如何维护这个\"Schema\"是一项关键的任务。只有将数据的\"Schema\"与数据实际的储存方式解耦，才能使数据湖解决方案具备足够的灵活性和扩展能力。而<a href=\"https://aws.amazon.com/glue/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AWS Glue</a>就承担了这一工作。</p>\n<p>AWS Glue有诸多功能，今天我们着重在其中两个最重要的部分：<code>Glue Data Catalog</code> 和 <code>Glue Crawler</code>。他们的关系如下图: <code>Glue Crawler</code>爬取数据湖中数据的Schema，并将元数据储存于<code>Glue Data Catalog</code>中。\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1b5f2d9f68b67c866a994ab37b4a5ebb/e5715/glue-catalog-and-crawler.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACCUlEQVR42pWTW2/TMBTH8/URH4AHxDu8ANIeYBLSWKtuMNRBq9F2vWW9pI3jOIkdx3F8OcZp0STQxsXyRbb1O+f8z7ED51zdNCWjtaiMMe5/WuBHFs7Gs3AcRigvUSFyLve0YbX2V/Bn2ChVXHUGt9H5d9QbxSeX04vRtr8gK8z9tbVgjX0UltqucbGO4ukinM7DcLObLhY7hGsp/+6ZCh0XzZ7KFRFrIu9Scb1SIW5q2erfTqP3zz9ofcgFGLA1QGONdND4fSCUpbUupVXGuwFl3J6c8WwoaRdHy/m38cXbS8nowZNiJb2bL9Mk1trzKpDKpNyR8opVp9o6r6/iPUlvMv4xLZXU4IxMCcu4cqbyBs66N+8+j9s4dBkco7fAjMXet1RaKxlPVucvB9qCVBaaJk7CfYGdbUNlVblPcUsYEdxnBaBdUYLRblOReLfdE7xLUgzKCXai9JemkgRtjJJ1xXiOf8L3zT+SPC9ESUG2Ihl/xeUWlDV16Y33x6MnrzsIbfuTxYvTT3mOfoGVrzmlLCdQs6OaYXeSRcgZ4S0PZrNnp9eEoM7w9umbHk53wQPls1qXhCQxQfGw9zVdr52pPUzTbbgMtchZnsTRxqnid/ioHBphBDWCga6g4WCtL4ziCaeZETklCEUrLbLgXz8B2MPD8LNpZ9+tegyGhw996kGB9b39Nj8ABT5ZyxVMXc0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"glue-catalog-and-crawler\"\n        title=\"\"\n        src=\"/static/1b5f2d9f68b67c866a994ab37b4a5ebb/8c557/glue-catalog-and-crawler.png\"\n        srcset=\"/static/1b5f2d9f68b67c866a994ab37b4a5ebb/4edbd/glue-catalog-and-crawler.png 175w,\n/static/1b5f2d9f68b67c866a994ab37b4a5ebb/13ae7/glue-catalog-and-crawler.png 350w,\n/static/1b5f2d9f68b67c866a994ab37b4a5ebb/8c557/glue-catalog-and-crawler.png 700w,\n/static/1b5f2d9f68b67c866a994ab37b4a5ebb/e5715/glue-catalog-and-crawler.png 768w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>3.1 Glue Data Catalog</h2>\n<p>为了使用Athena查询数据，和普通的关系型数据库一样首先需要创建\"Database\"和\"Table\"，而\"Table\"本质就是对数据湖中数据规定的一系列Schema，数据的存储位置以及数据序列化/反序列化标准等元数据。最简单的创建\"Table\"方式是在Athena console中使用Trino SQL。假设我们有如下的账户数据(对于JSON格式的数据，Athena要求使用<a href=\"http://ndjson.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ndjson</a>格式，每一行是一条完整的json)</p>\n<pre><code class=\"language-json\">{\"account_number\":1,\"balance\":39225,\"firstname\":\"Amber\",\"lastname\":\"Duke\",\"age\":32,\"gender\":\"M\",\"address\":\"880 Holmes Lane\",\"employer\":\"Pyrami\",\"email\":\"amberduke@pyrami.com\",\"city\":\"Brogan\",\"state\":\"IL\"}\n{\"account_number\":6,\"balance\":5686,\"firstname\":\"Hattie\",\"lastname\":\"Bond\",\"age\":36,\"gender\":\"M\",\"address\":\"671 Bristol Street\",\"employer\":\"Netagy\",\"email\":\"hattiebond@netagy.com\",\"city\":\"Dante\",\"state\":\"TN\"}\n{\"account_number\":13,\"balance\":32838,\"firstname\":\"Nanette\",\"lastname\":\"Bates\",\"age\":28,\"gender\":\"F\",\"address\":\"789 Madison Street\",\"employer\":\"Quility\",\"email\":\"nanettebates@quility.com\",\"city\":\"Nogal\",\"state\":\"VA\"}\n</code></pre>\n<p>该数据储存在<code>athena-data</code>bucket的<code>accounts</code>文件夹下，则运行SQL</p>\n<pre><code class=\"language-sql\">CREATE EXTERNAL TABLE `accounts`(\n  `account_number` int, \n  `balance` bigint, \n  `firstname` string,\n  `lastname` string,\n  `age` int,\n  `gender` string,\n  `address` string,\n  `employer` string,\n  `email` string,\n  `city` string,\n  `state` string) -- 数据的结构\nROW FORMAT SERDE \n  'org.openx.data.jsonserde.JsonSerDe' -- 指定SerDe\nLOCATION\n  's3://athena-data/accounts' -- 指定S3地址\n</code></pre>\n<p>这样，一张Glue Data Catalog的就创建完成了。注意与在<code>MySQL</code>中创建表不同的是，这里需要指定<code>ROW FORMAT</code>和S3<code>LOCATION</code>。其中<code>org.openx.data.jsonserde.JsonSerDe</code>代表使用内置的JSON序列化/反序列化去处理S3中的数据，如果源数据的格式不是JSON，而是诸如<code>csv</code>或<code>Parquet</code>之类的格式，则要指定对应的SerDe。有了这些元数据，任何一个数据的消费者或者生产者都可以在不关心实际S3存储的基础上，对数据进行操作，也就是完成了数据存储与数据访问的解耦。</p>\n<p>创建完成后，就可以使用Trino SQL在Athena中查询数据了:</p>\n<pre><code class=\"language-sql\">SELECT * FROM \"accounts\" limit 10;\n</code></pre>\n<h2>3.2 Glue Crawler</h2>\n<p>手动使用SQL创建表很方便，但是仍然有很多问题:</p>\n<ul>\n<li>如果底层json数据的schema有变化，例如新增字段了，需要手动维护表结构</li>\n<li>数据查询时会扫描所有的json文件，因为Schema-on-read并不像传统SQL一样会建立index。数据插入时是没有Schema的并且是直接将文件上传至S3，所以不具备动态维护index的条件</li>\n</ul>\n<p>为了解决这些问题，我们可以使用Glue Crawler来自动爬取S3中数据的Schema，并自动为数据创建partition。</p>\n<p>首先，我们为Crawler指定一个目标S3路径，比如</p>\n<pre><code>s3://athena-data/accounts/\n</code></pre>\n<p>以及输出的database，那么Crawler就会扫描<code>s3://athena-data/accounts/</code>下的文件(可以配置成仅扫描上次扫描以来的新增文件)，并在目标database中创建一张名为\"accounts\"的表(与S3目标地址最后一级目录名相同)。在扫描的过程中，crawler会自动按照文件的格式选取合适的SerDe进行序列化/反序列化，并提取文件中的字段形成对应的Schema储存在表结构中。</p>\n<p>其次，为了提高查询时的效率，我们需要为table创建partition。每个partition包含全体数据的一个子集，这样当查询的<code>where</code>条件匹配了partition的字段，Athena就会只在该partition的文件内查询，从而提高效率。例如上述\"accounts\"表创建时加入partition字段</p>\n<pre><code class=\"language-sql\">PARTITIONED BY ( \n  `city` string,\n  `state` string)\n</code></pre>\n<p>并且储存数据的时候把不同'state'和'city'的数据分开存放，例如</p>\n<pre><code>s3://athena-data/accounts/va/nogal/accounts.json\n</code></pre>\n<p>然后手动添加partition</p>\n<pre><code class=\"language-sql\">ALTER TABLE accounts ADD\n  PARTITION (state = 'va', city = 'nogal') LOCATION 's3://athena-data/accounts/va/nogal/'\n</code></pre>\n<p>那么在查询</p>\n<pre><code class=\"language-sql\">SELECT * FROM \"accounts\" where city='nogal' limit 10;\n</code></pre>\n<p>时，只会扫描<code>s3://athena-data/accounts/va/nogal/</code>下的文件。</p>\n<p>然而手动添加过于繁琐，如果想要实现自动添加partition，那么在存放文件的时候符合一定的格式，并且这个格式是与<a href=\"https://hive.apache.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Apache Hive</a>所使用的格式是一致的。例如上述的<code>accounts</code>数据，如果现在想按照\"state\"和\"city\"字段创建partition，需要按照如下格式组织文件。</p>\n<pre><code>s3://athena-data/accounts/state=va/city=nogal/accounts.json\ns3://athena-data/accounts/state=tn/city=dante/accounts.json\n</code></pre>\n<p>使用这种形如<code>key=value</code>格式的文件夹名，并且创建表的时候也添加了对应的<code>PARTITIONED BY</code>字段，那么运行</p>\n<pre><code class=\"language-sql\">MSCK REPAIR TABLE accounts;\n</code></pre>\n<p>就会为所有检测到的文件夹自动创建partition了。该操作也与<code>Hive</code>保持一致。</p>\n<p>上述的方法比较适合固定不变的数据，如果数据变动有新的文件夹被创建，那么就需要手动再跑一次<code>MSCK REPAIR TABLE accounts</code>才能创建出新的partition。对于变动的数据，Glue Crawler在爬取数据的时候就会自动在data catalog中加入对应的partition。当我们运行SQL</p>\n<pre><code class=\"language-sql\">SELECT * FROM \"accounts\" where city='nogal' limit 10;\n</code></pre>\n<p>加入其他state文件夹中不存在名为'city=nogal'的文件夹了，那么这次查询Athena只会扫描<code>s3://athena-data/accounts/state=va/city=nogal/</code>下的文件。</p>\n<p>此时我们查看表<code>accounts</code>的创建DDL</p>\n<pre><code class=\"language-sql\">SHOW CREATE TABLE `accounts`;\n</code></pre>\n<p>可以得到如下结果</p>\n<pre><code class=\"language-sql\">CREATE EXTERNAL TABLE `accounts`(\n  `account_number` int  COMMENT 'from deserializer', \n  `balance` bigint  COMMENT 'from deserializer', \n  `firstname` string  COMMENT 'from deserializer',\n  `lastname` string  COMMENT 'from deserializer',\n  `age` int  COMMENT 'from deserializer',\n  `gender` string  COMMENT 'from deserializer',\n  `address` string  COMMENT 'from deserializer',\n  `employer` string  COMMENT 'from deserializer',\n  `email` string  COMMENT 'from deserializer')\nPARTITIONED BY ( \n  `city` string,\n  `state` string)\nROW FORMAT SERDE \n  'org.openx.data.jsonserde.JsonSerDe' \nWITH SERDEPROPERTIES ( \n  'paths'='account_number,balance,firstname,lastname,age,gender,address,employer','email') \nSTORED AS INPUTFORMAT \n  'org.apache.hadoop.mapred.TextInputFormat' \nOUTPUTFORMAT \n  'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'\nLOCATION\n  's3://athena-data/accounts'\nTBLPROPERTIES (\n  'CrawlerSchemaDeserializerVersion'='1.0', \n  'CrawlerSchemaSerializerVersion'='1.0', \n  'UPDATED_BY_CRAWLER'='accounts-crawler', \n  'averageRecordSize'='374', \n  'classification'='json', \n  'compressionType'='none', \n  'objectCount'='1309', \n  'recordCount'='1309', \n  'sizeKey'='630830', \n  'typeOfData'='file')\n</code></pre>\n<p>可以看到除了一些crawler的元信息外，Crawler自动为我们添加了PARTITIONED BY`字段。并且将来有更多数据加入数据湖时，定期使用Crawler爬取数据可以自动更新表结构和Partition。需要注意的是如果有新的partition文件夹产生了，那么这些新partition中的数据在被Crawler爬取或手动增加partition之前，是无法被查询到的。</p>\n<h1>4. 总结</h1>\n<p>这次我们从总体上了解了构成AWS数据湖的几个最基本的服务：AWS S3, Glue和Athena，并介绍了他们各自在整个数据湖架构中的位置和作用。实际上如果把一个数据库的组成分解为数据存储，数据Schema以及查询解析引擎的话，那么这三个服务就分别实现了这些要求，也可以将这个stack看做一套被拆分开的数据库实现。</p>\n<p>在下篇文章中，我们详细了解如何搭建这一套解决方案，并通过解决一些实际的问题:</p>\n<ul>\n<li>如果每一条数据都是一个ndjson文件，那么就算使用了partition，一个partition内的文件数过多是否会影响查询性能？</li>\n<li>通过Athena查询时使用了不在partition上的<code>where</code>条件，有没有办法有效地降低文件扫描的数量和耗时？</li>\n</ul>\n<h1>参考文献</h1>\n<ol>\n<li><a href=\"https://aws.amazon.com/big-data/datalakes-and-analytics/what-is-a-data-lake/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://aws.amazon.com/big-data/datalakes-and-analytics/what-is-a-data-lake/</a></li>\n<li><a href=\"https://aws.amazon.com/redshift/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://aws.amazon.com/redshift/</a></li>\n<li><a href=\"https://trino.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://trino.io/</a></li>\n<li><a href=\"https://spark.apache.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://spark.apache.org/</a></li>\n<li><a href=\"https://trino.io/Presto_SQL_on_Everything.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://trino.io/Presto_SQL_on_Everything.pdf</a></li>\n<li><a href=\"https://aws.amazon.com/glue/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://aws.amazon.com/glue/</a></li>\n<li><a href=\"http://ndjson.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://ndjson.org/</a></li>\n<li><a href=\"https://hive.apache.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://hive.apache.org/</a></li>\n</ol>","excerpt":"机器学习和大数据分析技术在过去十年内高速发展，到今天已经成为了现代化的服务与应用不可或缺的一部分。而搭建一套数据湖系统则是开始将机器学习与数据分析带到项目中的第一步。在这几篇文章里，我们将会学习到如何使用AWS Athena服务与S3文件存储搭建一套完整的数据湖解决方案。 1. AWS的数据湖 在AWS的这篇文章中，阐述了数据湖与数据仓库的主要区别。简单地概括一下即： “数据仓库”一般指存储结构化业务数据的系统，数据的Schema在数据存储时就已经确定(schema-on-write…","frontmatter":{"date":"December 21, 2022","path":"/aws-athena-s3-data-lake-architecture","title":"使用AWS Athena搭建基于S3的数据湖(1): 概念与架构"}}},"pageContext":{}},"staticQueryHashes":["2560569871","3584596544","63159454"],"slicesMap":{}}