{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/nest-js-source-code-reading-dependency-injection","result":{"data":{"markdownRemark":{"html":"<p>如果要说近几年NodeJS开发者中最流行和热门的MVC框架，那非<a href=\"https://github.com/nestjs/nest\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestJS</a>莫属了。下图是2012年至2023年Github上各个知名NodeJS Web框架的Star数趋势：\n<span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; '>\n      <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 70.85714285714285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/ElEQVQ4y31UDXeiMBDk//+0s1TP9jyrvaqA8mX4SkggAeaSWCy1tvteXpJ97DA7s+AMwwCzvos8z7Hb7bDdbu3ZxFgz1k3rHZvQi5UlREVRVRUYYxBC2AellOCcX3NTwCnYoCSGTsGhlMLzPLi/Zli5CzzO5wiCAIQQtG37hfGUzRWs76FIYnfL0BS+vK6x2KzwMHvAfr9HmqZQSv3Y4rh3OUHfNpeW67qG7weYL1zM549wXRer1cqy7rrue1bve88qdFVxzTlGF6NRcDyi0UybprF3s+4xGqZgsoXK0mvOAq7Xa8soSZK7Ln8Cu5mInpx1v/2n550wDO04GBNuC++B4P0s8xScaeOGBk1XQ3Qc/aBNMUDGBAN8T6Mx2q4FlXqsFENJIxT5EURyxDVDzCnCmkKNLhvdjKu2DZ2cgjJVg7QZSllaFlLPW+YFSAqBgko9v/pFhdaedZa9Y8Q37OIbDYVuJW9z1LLW9KTWSueoQnaIINjl/qGfuVw+BGdklZwiUF4hTkME4UG/JABLc3BSoiw5PD+G9+8NokzQiEx/OWcw3TqtTqBlrKei0DjdBdDE2/YV/snHKQrw9+kZ5yhFURbYbF5wCCP4hwM2f56RF2cksYfl75k2kyCMIiyXT/pcWGLOTz+GMRo7q+JLng4UhGcQvEVFmdZX4T9niT0UaFZ9fwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='node-framework-star-history' title='node-framework-star-history' src='/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/8c557/node-framework-star-history.png' srcset='/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/4edbd/node-framework-star-history.png 175w,\n/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/13ae7/node-framework-star-history.png 350w,\n/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/8c557/node-framework-star-history.png 700w,\n/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/e996b/node-framework-star-history.png 1050w,\n/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/2cefc/node-framework-star-history.png 1400w,\n/static/573e1a1a9cc4fc072b16ba0db8d1c9c3/4917c/node-framework-star-history.png 3152w' sizes='(max-width: 700px) 100vw, 700px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n    </span></p>\n<p>我们可以直观得看出，从2018年以来，<code class=\"language-text\">NestJS</code>就异军突起，力压<code class=\"language-text\">Egg</code>，<code class=\"language-text\">Hapi</code>和<code class=\"language-text\">Sails</code>，仅用两年时间就稳居最受环境的NodeJS框架至今。</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; '>\n      <a class='gatsby-resp-image-link' href='/static/58499ccb045c148964a7cb86d6530ab0/2bef9/nest-banner.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgklEQVQoz01TS08TYRRtCAU6nWfn2ce0HdrOdPqgvCyVNAVKeQkxMRIhqSYmxMSdIS5xAe6EIOwwKW7ExD3+CLf+Bn+Cf+B4v6/WuDj55s6dnO+ce+5EZFnFCJKkQKFTkGSMixJEVYOqaJBYn05F1QkJJAwb6awH07KhaDo03YSaMJBMZxEZETGw50kicxQdXT0HX7URpVohsiFhAjLBTmVQm28iLFeQy00jmcnxSy0nPSRkUAlRScITo4Cf3g5+FR7jOt2ETeQi9UZkMql2CyW02iuw7SR0w0IprMMkMpPqyP+WBVIZqg76po8f+U38Lj5FT89jjC7SiIzZEmgUpeoMtjZ3MFcOkCTbDVIb1OdhJUnhyOpQpYaoLGPL8PDFbeNbtgNHNSAqfxWSbVU3MNvq4OXrN+g/O8RSPoN6OUTQWIRDo+AK43HpH4RYHFOCiIygQpyKYzwm8PnGWI/el2cW0Wi2sb3fx25vAw8cDYGbQVBroNJYQISRpIjZcVJ8JsWiT4P2UAjKqNYbCMMq3GweJb8Mg/qt7iP4lRms7u1jvbOKTs7BUjXEfKs9tByJjOHo6BXu77/j7Ow97u6+4urqGucfznFxfoHT0zNcXn7E7e1neMUAc8tdvh6eX4E3XUTKNFGtzeLh2hYsFko0Oond3T1ONBjc4ubmE05O3nGSg4NDHB+/5c+DwQALzWVKOIBhUbqmDTftQqHAlrvbaHZ6UGkneSg6LWaCLSZJzpI9ZjtFH7Ne//kLrK6tw6Feys0jXwr5CEzLQTbjQkvoWFrZgOuV+BbwUERR5mBDj7FQpgQeEFvWickYJqgWqNZNZ0jqFfhfwqwn6WK/Nsd7GhH+AUonQY5dk7v2AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='nest-banner' title='nest-banner' src='/static/58499ccb045c148964a7cb86d6530ab0/8c557/nest-banner.png' srcset='/static/58499ccb045c148964a7cb86d6530ab0/4edbd/nest-banner.png 175w,\n/static/58499ccb045c148964a7cb86d6530ab0/13ae7/nest-banner.png 350w,\n/static/58499ccb045c148964a7cb86d6530ab0/8c557/nest-banner.png 700w,\n/static/58499ccb045c148964a7cb86d6530ab0/2bef9/nest-banner.png 1024w' sizes='(max-width: 700px) 100vw, 700px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<p>NestJS作为一个受<a href=\"https://github.com/spring-projects/spring-framework\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Spring</a>和<a href=\"https://github.com/angular/angular\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Angular</a>启发的框架，实现了非常优秀的依赖注入功能。那我们今天就从NestJS的启动过程开始，了解一下他是如何做好依赖注入这一件“小”事的吧。</p>\n<p><em>本文基于NestJS的<a href=\"https://github.com/nestjs/nest/tree/v9.3.9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">v9.3.9</a>版本</em></p>\n<h1>1. 名词解释</h1>\n<p>在我们开始读源码之前，不妨先梳理一下源码中出现的许多类的概念吧。这样在源码中遇到各式各样的变量和类，也能做到心中有数他们是用来做什么的。</p>\n<h2>1.1 代码结构</h2>\n<p>作为一个<a href=\"https://monorepo.tools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Monorepo</a>，Nest各个模块的源码在<a href=\"https://github.com/nestjs/nest/tree/v9.3.9/packages\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">packages</a>这个文件夹内。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">packages\n├── common\n├── core\n├── microservices\n├── platform-express\n├── platform-fastify\n├── platform-socket.io\n├── platform-ws\n├── testing\n└── websockets</code></pre></div>\n<p>其中有许多诸如<a href=\"https://www.npmjs.com/package/@nestjs/testing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@nestjs/testing</a>和<a href=\"https://www.npmjs.com/package/@nestjs/microservices\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@nestjs/testing</a>包。但我们今天将重点放在最核心的<a href=\"https://www.npmjs.com/package/@nestjs/core\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@nestjs/core</a>和<a href=\"https://www.npmjs.com/package/@nestjs/common\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@nestjs/common</a>上。</p>\n<h2>1.2 容器类</h2>\n<p><strong>NestContainer</strong></p>\n<p>容器是实现依赖注入的关键，而<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/container.ts#L24\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestContainer</a>是整个NestApp最外层的容器。其中除了几个类似于<code class=\"language-text\">ModuleCompiler</code>的工具外，主要包含了几个指向配置和具体模块的容器集合。</p>\n<ul>\n<li>globalModules: 存放全局模块</li>\n<li>modules: 存放用户定义的模块</li>\n<li>internalCoreModule: 存放内置模块</li>\n<li>_applicationConfig: 存放配置，主要包括<code class=\"language-text\">globalPipes</code>，<code class=\"language-text\">globalFilters</code>，<code class=\"language-text\">globalInterceptors</code>等等的全局配置</li>\n</ul>\n<p>可以看到，<code class=\"language-text\">NestContainer</code>作为一个最外层的容器，本身的主要作用就是用来存放配置以及各个模块的，可以说是容器的容器。</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 467px; '>\n      <a class='gatsby-resp-image-link' href='/static/fc7074fc529f3b59211f0a2941326817/85ff8/nest-contaienr.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 121.14285714285715%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAEbUlEQVQ4y6VV+VNaVxjln850mvzWGdOk0xhrTFLbhCQYV3AFNxREBFwQAVEEZFPhsSmLyGNTTs+94NJpf+hMmTnce89799zlO9/3NB2IH/9vG0DzmqhKtNUSWjfF/4S2WkHn7lYqaTq3TailDGKBHYlk0C1RTodRv0xCLST+BsH9A+QbpTRF29C0q3nc5GIIHjgRC+4jcrSHE/82SpkYWhUF9VIKjXJaonZ1jut8gkg+oErcFM7kYmK3GqF8nY8jENjD+roRZvM8rNZFWCwm2O2rsG+uwGZbln2v14l4LIBo9BCx2KFs78e5VBjtaoGCZQXFTBSubasUW19bgJXCto0luFwWYh1Oxxphho+CifiRFIlTMEahZDyAyKkfF8ljtISgWkyhQPU4X1zascHAydOOdRhdVsQTR1je3sDU5ioMW2vQ21Y42YcVLqQzGzFhXcL4ugm+YzeU8xPGNP8oeBL24ePsBJ71v8KPg7/i3fQYOS+0pmk8e/tacv0TOgTJjZkX8APHzwff4JfRL3AHdpGhYOupYCjig3ZxBj+PfMar758xvKBHmLsZWZ2X3Gty72bG5XtTlkW8lJwWA4ZReCgodiiPXC+mcUmLiHtwHjiw4bbDStg9W3KHLt6bGAveRghux+eCZW+z+97+FgInHqSSwV5QGOVqLo6CEsUVg1PsQfTz6QguBa+csu0icxFGQfDpRy7LE15TQx65ySjX6KE0VzhjYMRK54lum0ocy1Y5D0G5CFEsJO2R6fUfuYi0ngxKq5KRg8WlGeh0f2J+bhxLJgNMJj3mFiZhNE7B6VyjXQISIsrCg4medQQX4jWIO2zf3+GVEsEpPeVgtmx6HNjkvYi7Ez5zkrNxbCfv8rpoYj92mUliLCCenzwVFFEuUvAodIAB/Xf0ffsDfdzpt+U5GeX3tFLf1y73+/yUDJ5ww09fhvFS9wlDfH4Y9Py74Bv67MVQP158GJCThEWG6EfJvX+LD5wcpuAnowHPORb8b7SNnzUg8/TIRUYqSEH9xjImiTH6zMjMOOXkWWaJyAiBWeZ1OOKVzyYsXc7A949omwfBZklBJRt9kp9+iaf5KlsBBiAa6yLCd8Ruxd1HCGGfBx/WGOXq5RluiEohiRI9JdqyAMtVORuXPqvQgzV6sEYPqkoXdfq0Qc/Wcz3bNLhDYVyffwf7+3Z4GLnA4S7czAI3s+GA2ZPj8yYn1rzbyO3akGFlyrJo5FhMFKcFOULlbpvdHbJ88ciiRJmZt2OjWmi1HzHCqBrnJ1nSFpCmmVvcVWHPDj0Dpmcw5oYHsfJ1WPYdkzqoLC7dHZazTKMIEsyKNFs/d2pjmfLScylmQIzZk2bbJKrkIlwgzNIVZUASopwxgHmWujqD2lLL0Ny16lApqpwx1VgkRV5e9vI4zbFAiSeoZ2NQefktLtwSxZTp2WRwWlxQpb3qSgydzh006H317po3uOUK7VrpAWJ8z7UE2G8KsN9USw/9dqMqxbpfvU4H3U/p//8Jrb8AiZCRV79s1XAAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='nest-contaienr' title='nest-contaienr' src='/static/fc7074fc529f3b59211f0a2941326817/85ff8/nest-contaienr.png' srcset='/static/fc7074fc529f3b59211f0a2941326817/4edbd/nest-contaienr.png 175w,\n/static/fc7074fc529f3b59211f0a2941326817/13ae7/nest-contaienr.png 350w,\n/static/fc7074fc529f3b59211f0a2941326817/85ff8/nest-contaienr.png 467w' sizes='(max-width: 467px) 100vw, 467px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<p><strong>Module</strong></p>\n<p>在NestJS中，用户编写的各类<code class=\"language-text\">Controller</code>和<code class=\"language-text\">Service</code>都组织在一个<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/module.ts#L48\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Module</a>容器中。该容器不仅承载了我们编写的代码，也包含着模块与模块之间的依赖关系。</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 502px; '>\n      <a class='gatsby-resp-image-link' href='/static/3f88b6b91253697c042b9ca38e383e77/eea79/nest-module.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 165.14285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAhCAYAAADZPosTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGlklEQVRIx41WW1NbVRTuj3McHXxxxhdttfpifXe0pfqg493KrS0WsWgLjS20gFACBQoUEoSQ+z0hCblCUiAJCTn7nBPafn57h0rrgyMzi3322ut8Z12+tbJPgX/Pnj4Bmg08M2poahWYjfILUuHRf0kZR6KOZ8+eSiickmCiXMBWcB2ZiBONxymY5SwMKftZ6PuZ/yVGraRATz0RNVR3NhH0riLgtqOQDmN3O4FSPs51E3s7SUpCyT6fX5RKMYVqScoWtL00jvRDnDqiy48Lcdhsc5iaHMHsg3EsPLyPmZlxWK2jsNvnkEmHkN4KYisVRCoVUGtmK4Qs9fIsxX2NwE/EAT1kzvJUBiMuuPzr8IaccAcdiMQ8iMW93G/AG3bCwzUYdSOZ9KvVT3upl+tmwo+DYhIyWnpYQTEXwbpvDd13LegaGUL3vT+w4rbx62FcnxpFx/AgZQjDC1Z6GsLkyhwu3bmpbPvv31OgtVKSxTlohbxbiGHdv4YvB66hvecSvuBqYz7z2Qiu3LOg/XIH2q924tbshNKNLc1w34ULtO0euQXfy4DSwyicDNcydx+W+SkMPpjABj1OJQO4x5eH5iYxSDCr/aHK3/z6ktJZ5u/j7uI0/OEW4JPnHu6zgvl8DLlsFFsMM5OJqH2G3mQpKVmUTFg9y7PssV7ayjVHhxq76ZaHkpiCgHo2hiap0szFlJhyLWy2hHpD6sgGU9pQJ8/VM+ljkGaC/G1KQJNV1hnGvuMRnON3YGeynRPD8EyMIETqeKeY9OnWGmWIsdlJ+FgIL4vlmryr7MobK9DpeVNnlWWrCQLWPavYZf72mMd9rvID+y4b9h9aUZXCCpdXF1AJOLDHKlcXplGh7S7PDpl/QZ62ABmyxvzoj2aR/6wdmxfPI9d+Hsa8FSY5+fibrxA//wlSn3yMhuUGTBbq4JdebHKfoL56uRMGP6Klgiceaky6Qa+cH53D6JnTcJ37EPrMnzD8DiQunMfY6Xew9P5Z1H/rh7Hpx253B6aos757BsXvv4HhW1dOvQAYhkZK1Hp7ULnSjdrlLmhLD6AxlHr/z9R1oUqQxvgwRNyHw9uDqPZ0oNLTicObA9C8ay8AkoeC1ZN5FEyszk5Qz/REY+vpySDMdASm1FMnYl4FKvU6w1c6KcVEq8rNQ9JGjqBynmv2JdEredX0FU4dKZrUlXMcd7kTu3/2Gc7S54B7GfVy82AbR8fSPCiovUbC1jmm6gQ2aGNWqX8ux3YGn08AJW3I9kbEje2NZWTXFpEjPbbZXiXyq+hcwS77eodryWnDHulVpJ3c50mtIs/KZINgZzXltJHEFhxJVRr7SVYfyeoeu40I+zlkHUOUPRzlc4xrhJVPP3qACIkeYy+HSXwf38nZ5lXeT6rMeSZcdhz2XUW18xJqP/0A/c8RNFmIxtBvqFz6HlXqtBu/wpQF4Fnlx++UbYPvGJ6//sVDTmGTgFESdfSdt7F49j1UBvpI4iDyP3yLCeoU5779GkYigPLv/Zg9fRrj5GxCNgHflRgngLL8DLlML+IXL6Dw+UU07gxB0PMauyJJ3Ra7qH7tKtMTwOHwLWRlV1GqHT9CbNigMZqXPJQkFuxdk8C6Yxma/GrIBc29CoN7g3rNy9BYAC2wAYMFk7ZC2ko96/BPL4vHWxxhKZKTv15yFJHoOqsmOKJk9RTxyUPBcSU4++Sq5cnLgrSVklQYLWLLTimxQ4o+HmwQ0InDPKVA73a8FA+f3Whwrxc9tGVRqBO0Eztu9dzSR45p06gSyIVGehmOOQtsUzfhWx6Fd3EY/qU/EFgZg3d5DO6Ht1GKLnGorpK3dnrpgE4H9Nxf0NOL3G8QsC49JOA2v5SchubphvD2QHi61F6+qAX6oXs7Idwd0MJDTIUDInqHuq6Wna+Xw/URnXKeAGoMqRm3IDr0Buy9ryM+1AYjPACTYZWsH8B+9VX4rr+G6vKnMJma+vrXcPa9Akff69ieOMPBQWf4oWNAVnnHDyM+jL3Jt7DW14ad0TdhRG6osMTSOXgH2hAZbIO+dpHReGG6v0PC0gbX9TdwMPcBjNT0sYeyyvwnCChSM9ADfWiG+qD7e7mf5g8XaRG6gWbwZw7bKxxdwypvIjYCM9ALM3gNemiAOVxQHz8yhLx9PeVNK0NQVrkUhVbk3JNCT8Q2q1cMMgJKMazOlZ7nmrSV+2OdUcny9sXrXOt++FTdnFr3vWpLOIqUPN8rqRzrqy/dEY903i0lGv/+Bn4P/GZucV0OAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='nest-module' title='nest-module' src='/static/3f88b6b91253697c042b9ca38e383e77/eea79/nest-module.png' srcset='/static/3f88b6b91253697c042b9ca38e383e77/4edbd/nest-module.png 175w,\n/static/3f88b6b91253697c042b9ca38e383e77/13ae7/nest-module.png 350w,\n/static/3f88b6b91253697c042b9ca38e383e77/eea79/nest-module.png 502w' sizes='(max-width: 502px) 100vw, 502px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<p>该容器的结构与我们在NestJS代码中定义一个Module的方式高度一致，</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Module</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  imports<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  controllers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  providers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  exports<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CatsModule</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>其中<code class=\"language-text\">_imports</code>中存放的是对其他模块的引用，<code class=\"language-text\">exports</code>中存放的<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/common/interfaces/modules/injection-token.interface.ts#L7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceToken</a>(即方便其他模块用来注入依赖的Token，而不是服务实例本身)之外，其他的<code class=\"language-text\">_providers</code>, <code class=\"language-text\">_injectables</code>, <code class=\"language-text\">_middlewares</code>和<code class=\"language-text\">_controllers</code>均指向了<code class=\"language-text\">InstanceWrapper</code>集合，即指向了真实的实例。</p>\n<p><strong>InstanceWrapper</strong></p>\n<p><a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-wrapper.ts#L59\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceWrapper</a>是对可注入对象实例的封装。</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 511px; '>\n      <a class='gatsby-resp-image-link' href='/static/6906a9ce536757bb0eb17e67083b1c56/92e00/nest-instance-wrapper.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 70.85714285714285%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADBElEQVQ4y3WU628bRRTF/Z/SAuJR0n5HSKjiA0JCKpSXCFUfQBAVqGkbJcFJnNiJUztxHk3s1I4fu47ttb1ZP+J4s7PrR/lxd00UhNSVzs6dO9pzZ849OyHkGXsOA7uN12/hnlsMLzrB/I3oX6I1GSXnc/hP6O/xkHb1mP1EhNxenL34EgcS280So57BoFtl2K0JqpP4TOIzYzL66wLVqaDaFcYDRWjk2biNIp3DLfLRvyjHVwJoAmN7nXpqnWoyirEVo7kbp7Ydo5JYk3k0yDf3NlHFNMrUGKrzfwlPsnR34hwsPKGwuoC+sUx6cZbc8hza+hKaFNJjYcqSz4afUVxbDOJCsIFlnIMkysgzcvsTQkcI3f0EZ7//QvPRPawH0wxkF6P8AZ2Zh1S+v0v9h7s44TnGpQz28z9p3J/GfPAT9vws6tUuql74D2HtGLW5ivHJx4SvvcWrGx9iP3mMk0lhfXabyPVrvHz/PfoP7+FIke6dL4m9fZ3Eu+/Q+/ZrVHYv4LgirOZwkzEatz9l88YH5G7dxJFd+JWtLz5n++YUh7emsH97hCt6db/5it2pj9iRwr0fv0Md7f6PsJIVHbbor8zTW3wmeIojDXGOdrBFK3t1MYAjDVF+LhrmfGGW3sJTLmTdkYZeHVlerlXGqxfxTB1P7OLDreXxxE6eOMBtlFA+jCKqkpePZb2pB1ANTfKlwDYj1SM0dm16pxqmEJpGgfapTlsKdFonmELWlFzPOsFty4fNl3inGUGagQ8rg2umAygzK4Rim9dyZEtarkn3dC1D4kWEyMocG+thdMlppTSNWkFIRBZ9jQs9Rv7FH8zP3CH+fBpb5qocRVWTcmRbdiiELTm/JmRl/Yik2CUuusQ3ligJmZ+v+4TWsfg1Rm7zMYfRGfYjv5IK32d/5WfO8kt4xpYYWzR8PfI4F5c3pdM+2maJjsx9NKVzjaqY3tfU8jXcEa1Tgsk48GMjhaptixwZxkOXUHA5DBxG8oOPLtoM7RbD/gRXucuLofNGXF4O/wBTIuGFupL6dQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='nest-instance-wrapper' title='nest-instance-wrapper' src='/static/6906a9ce536757bb0eb17e67083b1c56/92e00/nest-instance-wrapper.png' srcset='/static/6906a9ce536757bb0eb17e67083b1c56/4edbd/nest-instance-wrapper.png 175w,\n/static/6906a9ce536757bb0eb17e67083b1c56/13ae7/nest-instance-wrapper.png 350w,\n/static/6906a9ce536757bb0eb17e67083b1c56/92e00/nest-instance-wrapper.png 511w' sizes='(max-width: 511px) 100vw, 511px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<p>可能有同学会有疑问，为什么实例化的对象需要使用一层封装而不是直接储存该对象呢？主要出自于几个方面考虑:</p>\n<ul>\n<li>存放元数据: 其中最简单直接的原因是除了实例外，<code class=\"language-text\">InstanceWrapper</code>容器还存放了诸如<code class=\"language-text\">metaType</code>，即可注入对象的Class，用以创建对象，以及<code class=\"language-text\">subtype</code>，用以标记可注入对象是否为一个<code class=\"language-text\">guard</code>, <code class=\"language-text\">interceptor</code>, <code class=\"language-text\">pipe</code>或者<code class=\"language-text\">filter</code>这样的元数据。</li>\n<li>循环依赖问题: 为了解决循环依赖问题，整个NestJS将可注入对象的实例化分为了两步。第一步先通过原型链创建出该对象的实例，但不注入任何依赖，所以这一步我们可以获得所有服务的实例引用而不需要担心循环依赖的问题。第二步再向各个半成品实例注入依赖，此时服务的所有依赖不管有没有循环依赖的问题，均已有实例引用可以直接注入。而<code class=\"language-text\">InstanceWrapper</code>就是一个存放半成品实例和最终实例的容器。</li>\n<li>\n<p>Scope隔离问题: NestJS支持在<a href=\"https://docs.nestjs.com/fundamentals/injection-scopes\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不同Scope创建可注入对象</a>。其中Scope又分为三种：</p>\n<ul>\n<li>Default: 全局的单例，生命周期和整个nestApp一样长</li>\n<li>Request: 每个request生成一个单例，该单例在request结束后被销毁</li>\n<li>Transient: 每次注入时产生一个新的实例</li>\n</ul>\n</li>\n</ul>\n<p>所以当依赖注入的时候，需要根据当前Scope，注入一个对应的实例。<code class=\"language-text\">InstanceWrapper</code>中对象的实例实际储存在一个<code class=\"language-text\">WeakMap</code>中，将实例与他对应的<code class=\"language-text\">ContextId</code>做一一映射。</p>\n<p><strong>InstanceLinksHost</strong></p>\n<p>NestJS除了普通的依赖注入外，还提供了一个<a href=\"https://docs.nestjs.com/standalone-applications\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Standalone</a>模式，即绕过依赖注入的流程，直接从NestApp中获取依赖的实例</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> NestFactory<span class=\"token punctuation\">.</span><span class=\"token function\">createApplicationContext</span><span class=\"token punctuation\">(</span>AppModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> tasksService <span class=\"token operator\">=</span> app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>TasksService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>从上文中我们知道，Nest的依赖结构是一个树状结构，从根Module开始，不断地向imports Module的方向延伸。这是否意味着我们每次通过Standalone模式获取依赖都需要遍历一遍整颗依赖树来搜索呢？实际上Nest将整颗依赖树拍平，把所有可注入对象的引用放到了<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-links-host.ts#L16\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceLinksHost</a>的Map中，这样就可以在O(1)时间复杂度内找到对应的依赖了。</p>\n<h1>2. 启动流程</h1>\n<p>在对NestJS内部使用的容器有了初步的认识后，我们就可以开始跟随其启动过程阅读NestJS的源码了。当我们使用形如</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">await</span> NestFactory<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>AppModule<span class=\"token punctuation\">)</span></code></pre></div>\n<p>的代码启动NestJS时，调用了<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/nest-factory.ts#LL69\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestFactoryStatic.create</a>方法。该方法的关键代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token comment\">// 创建配置和容器的实例</span>\n    <span class=\"token keyword\">const</span> applicationConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApplicationConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> container <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NestContainer</span><span class=\"token punctuation\">(</span>applicationConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n\n    <span class=\"token comment\">// 初始化模块，实例化对象，完成依赖注入</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span>\n      moduleCls<span class=\"token punctuation\">,</span>\n      container<span class=\"token punctuation\">,</span>\n      graphInspector<span class=\"token punctuation\">,</span>\n      applicationConfig<span class=\"token punctuation\">,</span>\n      appOptions<span class=\"token punctuation\">,</span>\n      httpServer<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 创建NestApp实例并为其创建代理</span>\n    <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NestApplication</span><span class=\"token punctuation\">(</span>\n      container<span class=\"token punctuation\">,</span>\n      httpServer<span class=\"token punctuation\">,</span>\n      applicationConfig<span class=\"token punctuation\">,</span>\n      graphInspector<span class=\"token punctuation\">,</span>\n      appOptions<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">createNestInstance</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>createAdapterProxy<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> httpServer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到该方法主要是将一些基础的容器创建出来后，进入了下一步初始化。而整个依赖树的解析，实例化和依赖注入，都包含在这个<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/nest-factory.ts#L191\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">initialize</a>方法中。核心代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">async</span> <span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n\n    <span class=\"token keyword\">const</span> injector <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Injector</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> preview<span class=\"token operator\">:</span> options<span class=\"token punctuation\">.</span>preview <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> instanceLoader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InstanceLoader</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> metadataScanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MetadataScanner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> dependenciesScanner <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DependenciesScanner</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 用过模块间的依赖关系，创建出依赖树</span>\n      <span class=\"token keyword\">await</span> dependenciesScanner<span class=\"token punctuation\">.</span><span class=\"token function\">scan</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 实例化模块中的可注入对象，并进行依赖注入</span>\n      <span class=\"token keyword\">await</span> instanceLoader<span class=\"token punctuation\">.</span><span class=\"token function\">createInstancesOfDependencies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 应用全局enhancer</span>\n      dependenciesScanner<span class=\"token punctuation\">.</span><span class=\"token function\">applyApplicationProviders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleInitializationError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到这里主要做了两件事，实例化一些工具并执行真正的依赖树创建和依赖注入。首先，我们解释一下这里创建的四个工具实例分别是用来做什么的</p>\n<ul>\n<li><strong>Injector</strong>: 依赖注入工具，几乎没有成员变量，主要的工作是根据将代码中注册在各个module中的Class进行实例化，注入该类的依赖。Injector本身只负责依赖注入，并不负责依赖关系的扫描。</li>\n<li><strong>InstanceLoader</strong>: 调用上述的Injector,对一个Nest module的<code class=\"language-text\">providers</code>, <code class=\"language-text\">injectables</code>和<code class=\"language-text\">controllers</code>进行实例化和依赖注入.</li>\n<li><strong>MetadataScanner</strong>: 扫描一个类型的整个原型链，返回所有的方法名。</li>\n<li><strong>DependenciesScanner</strong>: 从root module开始，深度优先扫描整个依赖树，将扫描到的模块注册在NestContainer中。</li>\n</ul>\n<p>直接看着四个工具类的描述可能相当不直观，没办法一下子理解他们各自的功能。接下来我们就重点关注一下<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L75\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dependenciesScanner.scan</a>和<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-loader.ts#L25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">instanceLoader.createInstancesOfDependencies</a>这两个方法，梳理一下依赖注入的过程吧。</p>\n<h2>2.1 依赖树构造</h2>\n<p><a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L75\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dependenciesScanner.scan</a>方法非常简单：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">scan</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">module<span class=\"token operator\">:</span> Type<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 注册核心模块</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">registerCoreModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 深度优先扫描模块，构造模块依赖树</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">scanForModules</span><span class=\"token punctuation\">(</span>module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 扫描模块的依赖，向容器注册</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">scanModulesForDependencies</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">calculateModulesDistance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">addScopedEnhancersMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">bindGlobalScope</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>registerCoreModule</strong></p>\n<p>在注册其余模块前，Nest需要先初始化核心模块。其主要包括<code class=\"language-text\">ExternalContextCreator</code>, <code class=\"language-text\">ModulesContainer</code>, <code class=\"language-text\">HttpAdapterHost</code>等Providers。由于这次的重点是依赖注入的实现，对于核心模块的功能先不赘述。</p>\n<h3>2.1.1 模块的递归扫描</h3>\n<p><strong>scanForModules</strong></p>\n<p>从<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L85\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">scanForModules</a>开始，终于进入了模块依赖树的扫描阶段。下面仅列出关键代码，并省略了dynamic module的处理。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">scanForModules</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Promise<span class=\"token operator\">&lt;</span>Module<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 实例化module并将module加入全局容器NestContainer中</span>\n    <span class=\"token keyword\">const</span> moduleInstance <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">insertModule</span><span class=\"token punctuation\">(</span>moduleDefinition<span class=\"token punctuation\">,</span> scope<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token comment\">// ctxRegistry用于记录已扫描的module</span>\n    ctxRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>moduleDefinition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token comment\">// 从reflect metadata中取出当前module依赖的所有module</span>\n    <span class=\"token keyword\">const</span> modules <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectMetadata</span><span class=\"token punctuation\">(</span>\n          <span class=\"token constant\">MODULE_METADATA</span><span class=\"token punctuation\">.</span><span class=\"token constant\">IMPORTS</span><span class=\"token punctuation\">,</span>\n          moduleDefinition <span class=\"token keyword\">as</span> Type<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">let</span> registeredModuleRefs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 遍历当前模块所依赖的所有模块</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">,</span> innerModule<span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> modules<span class=\"token punctuation\">.</span><span class=\"token function\">entries</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ctxRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>innerModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 遇到已经扫描过的module，则跳过</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 递归调用自身</span>\n      <span class=\"token keyword\">const</span> moduleRefs <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">scanForModules</span><span class=\"token punctuation\">(</span>\n        innerModule<span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>scope<span class=\"token punctuation\">,</span> moduleDefinition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        ctxRegistry<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      registeredModuleRefs <span class=\"token operator\">=</span> registeredModuleRefs<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>moduleRefs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>moduleInstance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> registeredModuleRefs<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>moduleInstance<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>registeredModuleRefs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>该方法一开始调用了<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L144\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">insertModule</a>，该方法比较简单，实际上进一步调用了<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/container.ts#L67\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestContainer.addModule</a>实例化module并将module加入全局容器NestContainer中。其中比较关键的代码是:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">...</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> type<span class=\"token punctuation\">,</span> dynamicMetadata<span class=\"token punctuation\">,</span> token <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>moduleCompiler<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>\n      metatype<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span>\n<span class=\"token keyword\">const</span> moduleRef <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Module</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">,</span> moduleRef<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span></code></pre></div>\n<p>这段代码也相对好理解，首先使用<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/compiler.ts#L17\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ModuleCompiler.compile</a>将Module class转换为<code class=\"language-text\">type</code>(Module class本身), <code class=\"language-text\">dynamicMetadata</code>(dynamic module的imports, providers等)以及<code class=\"language-text\">token</code>(用来储存或获取一个Module实例的key)。随后为该模块创建一个仅包含class信息的<code class=\"language-text\">Module</code>容器，并使用<code class=\"language-text\">token</code>注册在NestContainer中。</p>\n<p>在获取到当前Module的容器后，使用常量<code class=\"language-text\">MODULE_METADATA.IMPORTS</code>从reflectMetadata中获取当前模块所依赖的所有模块。也就是我们通过装饰器<code class=\"language-text\">@Module</code>定义模块时</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Module</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  imports<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  providers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  exports<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CatModule</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>装饰器向模块Class写入的信息。最后对于这些当前模块的依赖模块逐一进行递归调用<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L85\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">scanForModules</a>，就能将从根模块出发所能搜索到的所有模块都创建好对应容器，并注入到注册在NestContainer中了。</p>\n<h3>2.1.2 模块依赖扫描</h3>\n<p><a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L163\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">scanModulesForDependencies</a>的方法体很简单:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">scanModulesForDependencies</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">modules<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Module<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">getModules</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>token<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> metatype <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">of</span> modules<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectImports</span><span class=\"token punctuation\">(</span>metatype<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> metatype<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectProviders</span><span class=\"token punctuation\">(</span>metatype<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectControllers</span><span class=\"token punctuation\">(</span>metatype<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectExports</span><span class=\"token punctuation\">(</span>metatype<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>遍历上一步扫描出来的所有Module并反射出每个Module的<code class=\"language-text\">imports</code>, <code class=\"language-text\">providers</code>, <code class=\"language-text\">controllers</code>以及<code class=\"language-text\">exports</code>。</p>\n<p>我们先来看<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L174\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reflectImports</a>。这个方法再次利用反射获取了一个模块的所有依赖模块，并对这些依赖模块，也就是<code class=\"language-text\">imports</code>里声明的模块调用了<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/container.ts#L148\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestContainer.addImport</a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">addImport</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">relatedModule<span class=\"token operator\">:</span> Type<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span> <span class=\"token operator\">|</span> DynamicModule<span class=\"token punctuation\">,</span>\n    token<span class=\"token operator\">:</span> string<span class=\"token punctuation\">,</span></span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> moduleRef <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> token<span class=\"token operator\">:</span> relatedModuleToken <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>moduleCompiler<span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span>\n      relatedModule<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 当前处理的模块</span>\n    <span class=\"token keyword\">const</span> related <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>modules<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>relatedModuleToken<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    moduleRef<span class=\"token punctuation\">.</span><span class=\"token function\">addRelatedModule</span><span class=\"token punctuation\">(</span>related<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>这段代码中<code class=\"language-text\">relatedModule</code>代表被依赖的模块，而<code class=\"language-text\">related</code>则代表当前正在处理的模块。通过调用<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/module.ts#L543\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Module.addRelatedModule</a>将被依赖模块的实力加入到当前模块的<code class=\"language-text\">_imports</code>集合中。这样，当所有模块都处理完成后，每个模块以及其<code class=\"language-text\">_imports</code>集合就形成了一个模块的依赖树。</p>\n<p>对于剩余的三个方法，处理手法均大同小异。与上述<code class=\"language-text\">addImport</code>不同的是，所有的Module在上一轮的扫描中均已创建了对应的容器。而Provider们则是第一次被处理。所以在最终调用<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/module.ts#L274\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Module.addProvider</a>时，需要先将Provider的容器<code class=\"language-text\">InstanceWrapper</code>创建出来。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">...</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_providers<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>\n      provider<span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">InstanceWrapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        token<span class=\"token operator\">:</span> provider<span class=\"token punctuation\">,</span>\n        name<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>provider <span class=\"token keyword\">as</span> Type<span class=\"token operator\">&lt;</span>Injectable<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>\n        metatype<span class=\"token operator\">:</span> provider <span class=\"token keyword\">as</span> Type<span class=\"token operator\">&lt;</span>Injectable<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n        instance<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n        isResolved<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n        scope<span class=\"token operator\">:</span> <span class=\"token function\">getClassScope</span><span class=\"token punctuation\">(</span>provider<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        durable<span class=\"token operator\">:</span> <span class=\"token function\">isDurable</span><span class=\"token punctuation\">(</span>provider<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        host<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span></code></pre></div>\n<p>此时<code class=\"language-text\">InstanceWrapper</code>相当于一个空容器，仅记录了一些元数据，并没有任何实例。</p>\n<p>另一个不点是，对于<code class=\"language-text\">Controller</code>，我们可以使用诸如<code class=\"language-text\">@UsePipes</code>, <code class=\"language-text\">@UseInterceptors</code>, <code class=\"language-text\">@Post</code>等装饰器注入一些<code class=\"language-text\">enhancer</code>或者定义一些路由规则。对于这一部分的处理存在于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/scanner.ts#L219\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reflectDynamicMetadata</a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token function\">reflectDynamicMetadata</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cls<span class=\"token operator\">:</span> Type<span class=\"token operator\">&lt;</span>Injectable<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> token<span class=\"token operator\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cls <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>cls<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectInjectables</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> <span class=\"token constant\">GUARDS_METADATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectInjectables</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> <span class=\"token constant\">INTERCEPTORS_METADATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectInjectables</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> <span class=\"token constant\">EXCEPTION_FILTERS_METADATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectInjectables</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> <span class=\"token constant\">PIPES_METADATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">reflectParamInjectables</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">,</span> <span class=\"token constant\">ROUTE_ARGS_METADATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过对应的常量反射出这些额外的注解，并注册到<code class=\"language-text\">NestContainer</code>中等待被注入。</p>\n<p>至此，整个模型依赖树的扫描就完成了。</p>\n<h2>2.2 可注入对象的实例化与依赖注入</h2>\n<p>扫描完整个模块的依赖树后，就可以把模块中定义的各种可注入对象实例化了。平时我们实例化对象时使用<code class=\"language-text\">new</code>关键字即可，但是当我们实现一个依赖注入工具时，由于这些对象之间又有依赖关系，同时也会存在循环依赖的问题，所以很可能没办法找到一个合理的顺序，将这些对象一个一个调用<code class=\"language-text\">new</code>关键字实例化出来。为了解决这个问题，NestJS将对象的实例化拆成的两个部分，第一步使用<code class=\"language-text\">Object.create</code>先从原型链创建出每个对象的实例，此时由于没有调用对象的构造函数，不需要担心对象之间的依赖关系。当获得所有对象的实例后，就可以再为这些对象寻找到它们的依赖并进行依赖注入了。整个依赖注入的实例化和注入过程入口在<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-loader.ts#L25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceLoader.createInstancesOfDependencies</a>方法中。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> <span class=\"token function\">createInstancesOfDependencies</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">modules<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> Module<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">getModules</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 使用原型链创建空实例</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">createPrototypes</span><span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 装填实例</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">createInstances</span><span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>其实整个过程也并不复杂，一共分为从Prototype创建实例与依赖注入两个部分。</p>\n<h3>2.2.1 从原型创建实例</h3>\n<p>该过程的代码位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-loader.ts#L35\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceLoader.createPrototypes</a>，其实就是分别对一个module中的<code class=\"language-text\">Providers</code>, <code class=\"language-text\">Injectables</code>和<code class=\"language-text\">Controllers</code>分别从可注入Class的原型链创建实例。我们从<code class=\"language-text\">createPrototypesOfProviders</code>的角度观察，发现其核心代码位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L83\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.loadPrototype</a>。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token keyword\">public</span> loadPrototype<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">{</span> token <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> InstanceWrapper<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    collection<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span>InstanceToken<span class=\"token punctuation\">,</span> InstanceWrapper<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">,</span>\n    contextId <span class=\"token operator\">=</span> <span class=\"token constant\">STATIC_CONTEXT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>collection<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 获取InstanceWrapper</span>\n    <span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> collection<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 使用原型链创建空实例</span>\n    <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">createPrototype</span><span class=\"token punctuation\">(</span>contextId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 将新的InstanceWrapper写回</span>\n      <span class=\"token keyword\">const</span> wrapper <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InstanceWrapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>target<span class=\"token punctuation\">,</span>\n        instance<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      collection<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">,</span> wrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>在2.1节中，NestJS在扫描模块依赖树的过程中，为每个对象创建了<code class=\"language-text\">InstanceWrapper</code>对象作为容器，在实例化的步骤中就是将这些容器一一取出，由于容器中储存了目标对象的构造函数，这里可以很方便地调用<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-wrapper.ts#L327\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceWrapper.createPrototype</a>创建对象实例了。而该方法的本质就是调用<code class=\"language-text\">Object.create</code>来创建对象实例。</p>\n<p>在获得实例后，将该实例储存在<code class=\"language-text\">InstanceWrapper</code>容器中并写回Module容器里。</p>\n<h3>2.2.2 依赖注入</h3>\n<p>至此为止，NestJS终于要开始执行依赖注入了。该过程的入口在<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/instance-loader.ts#L43\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">InstanceLoader.createInstances</a>中，依然是分别对<code class=\"language-text\">Providers</code>, <code class=\"language-text\">Injectables</code>和<code class=\"language-text\">Controllers</code>进行依赖注入。我们依然跟随<code class=\"language-text\">createInstancesOfProviders</code>的视角观察这一过程吧。与创建实例一样，依赖注入的核心代码位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L102\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.loadInstance</a>中。</p>\n<p>该方法的结构比较复杂下面列出简化版的代码</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> loadInstance<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n    wrapper<span class=\"token operator\">:</span> InstanceWrapper<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    collection<span class=\"token operator\">:</span> Map<span class=\"token operator\">&lt;</span>InstanceToken<span class=\"token punctuation\">,</span> InstanceWrapper<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    moduleRef<span class=\"token operator\">:</span> Module<span class=\"token punctuation\">,</span>\n    contextId <span class=\"token operator\">=</span> <span class=\"token constant\">STATIC_CONTEXT</span><span class=\"token punctuation\">,</span>\n    inquirer<span class=\"token operator\">?</span><span class=\"token operator\">:</span> InstanceWrapper<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">const</span> token <span class=\"token operator\">=</span> wrapper<span class=\"token punctuation\">.</span>token <span class=\"token operator\">||</span> wrapper<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> inject <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> wrapper<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> targetWrapper <span class=\"token operator\">=</span> collection<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token comment\">// 定义callback，该hook在解析出对象的所有依赖后被调用，用以执行</span>\n    <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">callback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">instances<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 从对象构造函数中提取依赖</span>\n    <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolveConstructorParams<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n      wrapper<span class=\"token punctuation\">,</span>\n      moduleRef<span class=\"token punctuation\">,</span>\n      inject<span class=\"token punctuation\">,</span>\n      callback<span class=\"token punctuation\">,</span>\n      contextId<span class=\"token punctuation\">,</span>\n      wrapper<span class=\"token punctuation\">,</span>\n      inquirer<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>在这段代码中，Nest先通过分析构造函数，提取当前对象的依赖，即分析出需要注入哪些依赖给当前对象。在提取完成后，利用一个callback来执行真正的依赖注入。这个callback我们一会再说，先来看看Nest是如何提取对象依赖的。</p>\n<p>提取依赖的过程位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L251\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.resolveConstructorParams</a>。这里又分为了两步：先获取对象的依赖列表，然后在查询出这些依赖对应的实例对象。</p>\n<p><strong>获取依赖列表</strong></p>\n<p>代码位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L317\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.getClassDependencies</a>。该方法提取了对象在构造函数中声明的依赖以及可选的依赖。其中构造函数的依赖通过<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L358\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.reflectConstructorParams</a>反射出来。该方法主要从对象的<code class=\"language-text\">reflectMetadata</code>中获取了键为<code class=\"language-text\">design:paramtypes</code>以及<code class=\"language-text\">self:paramtypes</code>的数据。</p>\n<p>其中<code class=\"language-text\">design:paramtypes</code>是Typescript原生支持的reflectMetadata。当你的代码以下面的形式声明依赖时</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Injectable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">AppService</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> readonly CatService</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>打开tsconfig配置中<code class=\"language-text\">emitDecoratorMetadata</code>这个选项后，代码经过<code class=\"language-text\">tsc</code>转移成js时，就会被转换为如下的形式</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">AppService <span class=\"token operator\">=</span> <span class=\"token function\">__decorate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> common_1<span class=\"token punctuation\">.</span>Injectable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">__metadata</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"design:paramtypes\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>CatService<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> AppService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>此时NestJS就可以从这个<code class=\"language-text\">design:paramtypes</code>来提取你声明依赖的Class了。详细的说明可以参考<a href=\"https://www.typescriptlang.org/tsconfig\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这篇文档</a></p>\n<p>而<code class=\"language-text\">self:paramtypes</code>这项reflectMetadata则是NestJS自己声明的，当你的依赖是通过<code class=\"language-text\">@Inject(token?)</code>形式注入时，依赖的token就会被写入到当前Class的<code class=\"language-text\">self:paramtypes</code>中。</p>\n<p><strong>查询依赖实例</strong></p>\n<p>获取到当前对象声明依赖的Class或者token后，就需要获取对应的实例了。具体的过程位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L494\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">injector.lookupComponent</a>。可注入的对象来源分为两种，第一个是与当前对象同Module的<code class=\"language-text\">providers</code>，或者是被当前模块通过<code class=\"language-text\">imports</code>引入模块的<code class=\"language-text\">exports</code>当中。对于第一种依赖比较简单，直接在当前的Module内搜索即可。对于第二种依赖，由于可能是通过层层<code class=\"language-text\">import</code>引入的依赖，则需要在依赖树上递归地寻找。具体的递归寻找过程位于<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L555\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">injector.lookupComponentInImports</a>。</p>\n<p>经过以上两步，<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/injector/injector.ts#L251\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Injector.resolveConstructorParams</a>方法就搜索到当前对象所声明依赖的所有实例了。此时调用callback来进行具体的依赖注入过程。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">callback</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">instances<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 获取属性依赖</span>\n  <span class=\"token keyword\">const</span> properties <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolveProperties</span><span class=\"token punctuation\">(</span>\n    wrapper<span class=\"token punctuation\">,</span>\n    moduleRef<span class=\"token punctuation\">,</span>\n    inject <span class=\"token keyword\">as</span> InjectionToken<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    contextId<span class=\"token punctuation\">,</span>\n    wrapper<span class=\"token punctuation\">,</span>\n    inquirer<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 装填实例</span>\n  <span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">instantiateClass</span><span class=\"token punctuation\">(</span>\n    instances<span class=\"token punctuation\">,</span>\n    wrapper<span class=\"token punctuation\">,</span>\n    targetWrapper<span class=\"token punctuation\">,</span>\n    contextId<span class=\"token punctuation\">,</span>\n    inquirer<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 装填属性</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">applyProperties</span><span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  wrapper<span class=\"token punctuation\">.</span>initTime <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getNowTimestamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> t0<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>该回调的输入参数<code class=\"language-text\">instances</code>即上一步搜索到的依赖实例。最后的注入过程分为了三步：</p>\n<p><strong>寻找可被注入的属性(resolveProperties)</strong></p>\n<p>除了上述两种依赖注入的方式外，NestJS还支持属性注入<a href=\"https://docs.nestjs.com/providers#property-based-injection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Property-based injection</a>。例如其官网上的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Injectable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HttpService</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token function\">Inject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'HTTP_OPTIONS'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> readonly httpClient<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>此时属性<code class=\"language-text\">httpClient</code>的依赖注入并不在构造函数上申明，而是单独调用了<code class=\"language-text\">@Inject(token?)</code>装饰器注入。此时这条注入信息被写入到了Class的reflectMetadata中的键<code class=\"language-text\">self:properties_metadata中。</code>resolveProperties`方法就是根据这个键去提取并寻找出当前对象的属性依赖。</p>\n<p><strong>创建实例(instantiateClass)</strong></p>\n<p>在获取了构造函数所声明的依赖的实例后，就可以将这些依赖注入到实例中了。实际上非常简单，直接调用<code class=\"language-text\">new</code>关键字就好了</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">instanceHost<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>metatype <span class=\"token keyword\">as</span> Type<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>instances<span class=\"token punctuation\">)</span></code></pre></div>\n<p>那么在2.2.1节中从原型链上创建出来的对象还有什么用呢？答案是如果是循环依赖的情况，不能新建对象，而是应该保留2.2.1节中创建好对象的引用。因为在循环依赖的情况下，在当前对象依赖注入之前，当前对象可能已经作为依赖被注入给别的对象了。在这种情况下新建对象就需要换一个方式来保持实例的引用不变:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">instanceHost<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>\n  instanceHost<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">new</span> <span class=\"token punctuation\">(</span>metatype <span class=\"token keyword\">as</span> Type<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>instances<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>将属性依赖赋予实例(applyProperties)</strong></p>\n<p>上一步中创建出的实例已经通过<code class=\"language-text\">new</code>关键字注入了构造函数声明的依赖，这一步也非常简单直接:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">iterate</span><span class=\"token punctuation\">(</span>properties<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token function\">isNil</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span>instance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>至此，整个依赖树的实例化以及依赖注入也完成了。而一些如<code class=\"language-text\">loadEnhancersPerContext</code>注入<code class=\"language-text\">enhancer</code>的过程这里就不再赘述了。</p>\n<h1>3. 总结</h1>\n<p>好了，我们这次以<a href=\"https://github.com/nestjs/nest/blob/v9.3.9/packages/core/nest-factory.ts#LL69\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NestFactoryStatic.create</a>为切入点，通过阅读源码学习了NestJS是如何实现依赖注入的。简单的说，总共分为这么几步</p>\n<ul>\n<li>从根模块出发，深度优先遍历模块的<code class=\"language-text\">imports</code>数组，构造一个模块的依赖树，同时为可注入对象创建容器</li>\n<li>遍历可注入对象，使用构造函数的原型在不使用<code class=\"language-text\">new</code>关键字的情况下创建实例(提前创建引用以解决循环依赖问题)</li>\n<li>对于每个可注入对象，通过分析<code class=\"language-text\">reflectMetadata</code>，获取其申明依赖的Class或者注入token</li>\n<li>获取当前对象依赖的实例</li>\n<li>使用构造函数创建出对象实例，并进一步装填对象</li>\n</ul>\n<p>相信在了解了整个过程后，你已经对基于<code class=\"language-text\">Typescript</code>的依赖注入原理以及思路有了比较全面的认识，也许你也可以试试写一个自己的小型依赖注入库。</p>\n<h1>参考链接</h1>\n<ol>\n<li><a href=\"https://github.com/nestjs/nest\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/nestjs/nest</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-framework\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/spring-projects/spring-framework</a></li>\n<li><a href=\"https://github.com/angular/angular\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/angular/angular</a></li>\n<li><a href=\"https://monorepo.tools/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://monorepo.tools/</a></li>\n<li><a href=\"https://docs.nestjs.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.nestjs.com</a></li>\n<li><a href=\"https://www.typescriptlang.org/tsconfig\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.typescriptlang.org/tsconfig</a></li>\n</ol>","excerpt":"如果要说近几年NodeJS开发者中最流行和热门的MVC框架，那非NestJS莫属了。下图是2012年至2023年Github上各个知名NodeJS Web框架的Star数趋势：\n 我们可以直观得看出，从2018年以来，就异军突起，力压，和，仅用两年时间就稳居最受环境的NodeJS框架至今。  NestJS作为一个受Spring和Angular启发的框架，实现了非常优秀的依赖注入功能。那我们今天就从NestJS的启动过程开始，了解一下他是如何做好依赖注入这一件“小”事的吧。 本文基于NestJS…","frontmatter":{"date":"March 09, 2023","path":"/nest-js-source-code-reading-dependency-injection","title":"NestJS源码精读(1): 启动与依赖注入"}}},"pageContext":{}},"staticQueryHashes":["1176552510","3649515864","63159454","846684790"]}