{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/building-claude-code-plugin-for-agent-teams","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>Based on real-world development experience from the Chorus project, this article systematically introduces Claude Code's plugin mechanism, with a focus on building plugins for Agent Teams (Swarm mode) and solving the context injection challenge in multi-agent collaboration.</p>\n</blockquote>\n<h2>TL;DR: What This Article Covers</h2>\n<p>Claude Code's Agent Teams (also known as Swarm mode) allow a Team Lead Agent to orchestrate multiple Sub-Agents working in parallel. This is a powerful capability — but it raises a question: <strong>when you have an external work tracking system, how do you automatically connect each Sub-Agent to your workflow without the Team Lead hand-writing boilerplate in every spawn prompt?</strong></p>\n<p>The main goals of this article are:</p>\n<ol>\n<li><strong>Introduce the Claude Code plugin ecosystem</strong> — Marketplace, Plugin Manifest, Hooks, Skills, and MCP configuration form a complete extension mechanism</li>\n<li><strong>Use Chorus as a case study</strong> to show how an Agent-first task management platform can seamlessly integrate with Claude Code's multi-agent workflow through plugins</li>\n<li><strong>Deep dive into Sub-Agent context injection</strong> — in multi-agent collaboration scenarios, ensuring each Sub-Agent automatically receives the correct working context is the key to whether a plugin can truly work in practice</li>\n</ol>\n<p>If you're considering building a Claude Code plugin for your own toolchain (CI/CD, project management, monitoring systems, etc.), we hope this article provides useful insights.</p>\n<hr>\n<h2>1. Claude Code Agent Teams: A Quick Look at Swarm Mode</h2>\n<p>Agent Teams is Claude Code's multi-agent collaboration mode. The core concept is simple:</p>\n<pre><code>Team Lead (main Agent)\n  ├── Task tool ──> Sub-Agent A (frontend-worker)\n  ├── Task tool ──> Sub-Agent B (backend-worker)\n  └── Task tool ──> Sub-Agent C (test-runner)\n</code></pre>\n<p>The Team Lead uses the <code>Task</code> tool to spawn multiple Sub-Agents, each being an independent Agent process with its own context window, tool access, and lifecycle. Sub-Agents communicate via <code>SendMessage</code> and collaborate through a shared filesystem.</p>\n<p>Key lifecycle events:</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>When Triggered</th>\n<th><code>additionalContext</code> Target</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>PreToolUse:Task</code></td>\n<td><strong>Before</strong> Team Lead calls the Task tool</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code>SubagentStart</code></td>\n<td>When Sub-Agent process starts (synchronous)</td>\n<td><strong>Sub-Agent</strong></td>\n</tr>\n<tr>\n<td><code>TeammateIdle</code></td>\n<td>When Sub-Agent goes idle (between turns)</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code>TaskCompleted</code></td>\n<td>When a Claude Code internal Task is marked complete</td>\n<td>Team Lead</td>\n</tr>\n<tr>\n<td><code>SubagentStop</code></td>\n<td>When Sub-Agent process exits</td>\n<td>Team Lead</td>\n</tr>\n</tbody>\n</table>\n<p>Note a critical distinction about where hook output goes:</p>\n<ul>\n<li>Most hooks (<code>PreToolUse:Task</code>, <code>TeammateIdle</code>, <code>TaskCompleted</code>, <code>SubagentStop</code>) inject <code>additionalContext</code> into the <strong>Team Lead's</strong> context</li>\n<li><strong><code>SubagentStart</code> is the exception</strong> — its <code>additionalContext</code> is injected directly into the <strong>Sub-Agent's</strong> context</li>\n</ul>\n<p>This means <code>SubagentStart</code> is the ideal hook for automatically providing Sub-Agents with working context (session IDs, workflow instructions, etc.) without relying on the Team Lead to hand-write boilerplate or the Sub-Agent to read files.</p>\n<hr>\n<h2>2. What Is Chorus, and What Problem Does It Solve</h2>\n<p>Before diving into the plugin implementation, let's briefly introduce Chorus.</p>\n<p><a href=\"https://github.com/Chorus-AIDLC/chorus\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Chorus</a> is a collaboration platform for AI Agents and humans, inspired by the <a href=\"https://aws.amazon.com/blogs/devops/ai-driven-development-life-cycle/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AI-DLC (AI-Driven Development Lifecycle)</a> methodology, implementing its core workflow from Idea to Verify:</p>\n<pre><code>Idea → Proposal → [Document + Task] → Execute → Verify → Done\n ^        ^            ^                 ^          ^        ^\nHuman   PM Agent    PM Agent         Dev Agent   Admin    Admin\n</code></pre>\n<p>The core philosophy is <strong>Reversed Conversation</strong>: AI proposes solutions, humans review and verify — rather than humans giving instructions for AI to execute.</p>\n<p>In multi-agent team scenarios, Chorus needs to solve a specific problem: <strong>Observability</strong>. When 5 Sub-Agents are writing code simultaneously:</p>\n<ul>\n<li>Which Agent is working on which Task?</li>\n<li>What's each Agent's progress?</li>\n<li>Are Task status transitions (open → in_progress → to_verify → done) happening correctly?</li>\n<li>Is the Agent still alive (heartbeat)?</li>\n</ul>\n<p>Chorus tracks all of this through a <strong>Session</strong> mechanism — each working Agent owns a Session, Sessions check in to Tasks, and the UI shows in real-time who's doing what.</p>\n<h3>What Chorus Looks Like in Practice</h3>\n<p>Words are always abstract — let's look at some actual screenshots.</p>\n<p><strong>Kanban Board — Real-time Agent Work Tracking</strong></p>\n<p><img src=\"/ca8741149e0391102f3de54df25fd18e/kanban-auto-update.gif\" alt=\"Kanban Board\"></p>\n<p>This is the core view of Chorus. Colored badges on each Task card show the Agent Sessions currently working on that Task. When a Sub-Agent calls <code>chorus_session_checkin_task</code>, the badge appears in real-time; it disappears after <code>checkout</code>. Task movement between columns (Open → In Progress → To Verify → Done) is driven by Agents through MCP tools.</p>\n<p><strong>Task Dependency Graph (DAG)</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/372d750d82b62550f37ee3a12b356f25/e6619/dag.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/0lEQVR42mWSS28TMRSF8zdYUBVIW0jTvDN5NglpHiRt0gJqUIBWiA0LfiQrJHbsswAjGozajMfOTDITz4wPngixwdKRjnR1P5977Rhj7Cvn/M5c3P1i5oIy06ScW5RbFrUYo0vB6e/5T3r9/iMdv7yiF5N3dPT8zVbjF2/pYDylw/PX8/7oFZtef/gck1LOgRDSW6tQetr6UMFfaQ8EsOgPNDtjpAotpPJNPEnXEE+U8OAgj514NlJ4bzeFtNGexTzXvdGdkNILhSkUX1jK4Y5it0xx01LS2yhhC9UfTVTGaCuj3leFSldltY+UK3e0ToLDbAPV5nAWC4NAJ1TYbNwIBJsvsbbXWJoCjrDhSwnBGXqnl8gUn+Io19gm3E+WtynjCQN7iVIY+fLxMw0Mw3/AJRewTIaVBrKFBWFx+L4E18Dh+RTFag86FdJ69CM9eqTDzDEOkpXw4ePi/0Buc1h8Ae4sccs4hL2C9P0tcHA2QbnWQ715GjWiUO0iX+kirVMnc40wka6j3jqbxYLtyNEJVAQOvBU824LvOlAq2FYcx0arewG9QxQ11Kj1kSudYD9Vx45OtruXD+8/yulLevpR1s6XjefdrNf2d89bEdcRxBYmWS05cVc28aVH9Lch/cElKZR7pFDvEKPWIxpI0sUWyRlt7dvf9Bpooz369AczBba+3N6aCQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"DAG\"\n        title=\"\"\n        src=\"/static/372d750d82b62550f37ee3a12b356f25/8c557/dag.png\"\n        srcset=\"/static/372d750d82b62550f37ee3a12b356f25/4edbd/dag.png 175w,\n/static/372d750d82b62550f37ee3a12b356f25/13ae7/dag.png 350w,\n/static/372d750d82b62550f37ee3a12b356f25/8c557/dag.png 700w,\n/static/372d750d82b62550f37ee3a12b356f25/e996b/dag.png 1050w,\n/static/372d750d82b62550f37ee3a12b356f25/2cefc/dag.png 1400w,\n/static/372d750d82b62550f37ee3a12b356f25/e6619/dag.png 3401w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Tasks in Chorus can declare dependencies, forming a directed acyclic graph. The PM Agent sets dependencies via <code>dependsOnDraftUuids</code> when creating Proposals. The UI uses dagre for automatic layout. The Team Lead can use this to decide spawn order — process Tasks with no dependencies first; when upstream Tasks complete, downstream Tasks automatically become unblocked.</p>\n<p><strong>Elaboration — Structured Requirements Clarification</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/56e4f4c00c30a7d138da103e4c7e645b/0ec65/elaboration.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.42857142857142%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9klEQVR42o2TW2+bQBCF+f+/pW99SKVWFuxy38Umu46V9CUhgVitWu4YU2Cns9iK+uC4Qfq0SAyHc2YG4+uXm2/EXN1TayVsYsqPgLWSB77MfubyV57LoijE0B92yeOjY3ium93GMUScqXizho+wWUewu9vCNI6gr3melT6zLKsM27FTxhggMwtDtcCYeru/QBgEStzGqq1ydRwGNQzDPKPgU5KUhkvMLIo4BL6vCyE4wzRheBGsBSkENHUFRVFC0zaLw+fkuTJWnz9lvkPAoUTZ1MLTAkpMcB0KvutcxLUpxBj70LXQti10XbcIJk9JZbjYQ59xcD1fLQ5O8Rc45xfRz4S4hUNTwTRNMI5/UHAEHEplEMvMUBQIIUqfPsbR6Fhci14gxA9LFKzLAqq6hr7vT5G1Q8ehGeORLlKca1enlxaXV3t4EizLEvrDYRF8SVN0SCx06AGlVHmeB5rF3TtxNWHIYCslVCiIO/gmmGpBHAY6PE85DGDhyoT/dVjmv6HGyMNwPO/ha2VQQlLbccG2nRl7p3zcMcb4aRffIcD2CCFU29RqHEelNxvmEV7Tl9LYrHl2t9uBLpBSLFG22+vouu8PD6gznf+UCUV7+JHhHlLLvFlZVKAzjnEjjBsF/wGTRHEcR1WZR13XRP3xyFE33u/35l9LoIBnxjZoxgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Elaboration\"\n        title=\"\"\n        src=\"/static/56e4f4c00c30a7d138da103e4c7e645b/8c557/elaboration.png\"\n        srcset=\"/static/56e4f4c00c30a7d138da103e4c7e645b/4edbd/elaboration.png 175w,\n/static/56e4f4c00c30a7d138da103e4c7e645b/13ae7/elaboration.png 350w,\n/static/56e4f4c00c30a7d138da103e4c7e645b/8c557/elaboration.png 700w,\n/static/56e4f4c00c30a7d138da103e4c7e645b/e996b/elaboration.png 1050w,\n/static/56e4f4c00c30a7d138da103e4c7e645b/2cefc/elaboration.png 1400w,\n/static/56e4f4c00c30a7d138da103e4c7e645b/0ec65/elaboration.png 2009w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Before an Idea becomes a Proposal, the PM Agent initiates Elaboration: structured questions about scope, technical choices, priorities, etc. Humans answer via interactive options. All Q&#x26;A is persisted as an audit trail on the Idea, ensuring design decisions are traceable — even verbal agreements from chat conversations get recorded.</p>\n<p><strong>Proposal — AI Proposes, Humans Review</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/7e117/proposal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5klEQVR42pVT207cMBDN/38CD+0Dn4KouoRW26qt1D4hBGVLdxPi29ie8U5nnCWbgIrA0dE4sX3meM6keej7U+/9V0xpNfTb1gy71vSCbttaiWCHNgbbgjNtkPl/sPLm4Zs13bsmQlzzOAomx3+3d7y9/83d5ob7+1sedhu2Q8c5Bd0ioBke31EnnBJcNCGEzyNdweBtcdYUgFCRUyxJEaEgplIIKwhzIcolgq9rhAmVQm7ysTHDsCZC1g0QPHsfWJIwhDHO4ZxjAOCcMyOixCTniA9SZY9dNcH79SiQSgyOjRk4RmCSAygHc0oSl9A1kciiTq6ZJkJrzaqRTJWQxqswyCYxqSoppfBLA3MUwljP6jsEdyTU2uQEHLwT6b4iQtDvqv4YZ8AMDLZXjISwICQtciV67ciiMDirV6+EcU6osjXrNPb7sX5qmBog80L0hDAtaig3eoFQXVNXxV111BlT44JQ6pdilO/5FQrHjIeiE4MYRU8VylqMR4UHU/JEqC2xUCgkCjXLW/vMdU3mQEzMcOxDKuXy4LLU1mvvTJA2knxJfhKocb6mChxY/P7nJ365+5FuYSMt5z5MCh9lv2Xs5aE9zRv7otld/XofrL2UhGfR2/O3ALwTwLlwnXW77tPN9fXJP6aviRvxk9S7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Proposal\"\n        title=\"\"\n        src=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/8c557/proposal.png\"\n        srcset=\"/static/fe044aeac6e0f3a7e2c2a47e9110700b/4edbd/proposal.png 175w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/13ae7/proposal.png 350w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/8c557/proposal.png 700w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/e996b/proposal.png 1050w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/2cefc/proposal.png 1400w,\n/static/fe044aeac6e0f3a7e2c2a47e9110700b/7e117/proposal.png 1715w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>This embodies the AI-DLC core philosophy of \"Reversed Conversation\": the PM Agent builds on the Elaboration conclusions to create a Proposal containing PRD document drafts and Task drafts. After Admin (human) approval, drafts are automatically materialized into real Document and Task entities.</p>\n<p><strong>Task Detail — Session Tracking</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/7e117/task-tracking.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPUlEQVR42qWTy07cQBBF/f9fkEWyyQdkk03QjD3uh91t95h5kR0LQCGBgN/Gj+lpimqbERBlBS1ddZdGc3xLt8rxPP8r53wrhIjmJz+U584U8Vzl4+17cxVQ8kaM+EoETP36c62y62t1//dWVVUVtW1zVlfVF0dKudput7BZr0wYMJCCwTIWo2TIIFECJUFF4Sj7XiUxNE0NQ9dBb9X3BvB0XScdxtgpHlBxpBmZm6M4W5gF3vgR45OZ8f2Zof4cNTMhX5gsS02aZubu7s4URaEtsG1b4VBKVkmSQBRJw6kHCBsVcB88zwXXdYFRgvUCOHUBgRAGPhRFDnVdQ1mW+C5Hh+gUHVI6AeUEtH+yskBKCBBKQUgBAZuA9mMh/lYWGQyDbbeFrn0wk8NGOnEcr87OfkIcReYIG4EICAMOYciBBeQ/wBz2Qw/7fQ9D343Apq7lGMput0Og/Af44naS9xaYp/BQV6gSmsq2bCDP0w8AywJTbbHtHtueHNa25fcCbSjDMMDj4yMYPGPLzXuBmHKW3o8JI8SOy/Mcth9wmOd2kDGUPWitX8bmvcD09jfU6M5uSvswjQ2uoHSiKF6u1xsLHDid66MC5urXNcLGm5GZFgHRWZrqq6srfXl5qS8uLoabmxvAd+Csk2R1fn4Ou+3GLOMAjkpUCG/qeKpVxOF0KewwYxgHOBwO6G0KBVuXjvv922fOWCyFILirDFfrWa/fM8afa+Kf4Ca6DAebYbgMR4bpgybmoFVbl5+eAFrvAC8u8QdyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Task Tracking\"\n        title=\"\"\n        src=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/8c557/task-tracking.png\"\n        srcset=\"/static/b39bfb150ebf36f2afc6b351c87b3d73/4edbd/task-tracking.png 175w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/13ae7/task-tracking.png 350w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/8c557/task-tracking.png 700w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/e996b/task-tracking.png 1050w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/2cefc/task-tracking.png 1400w,\n/static/b39bfb150ebf36f2afc6b351c87b3d73/7e117/task-tracking.png 1715w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The Task detail page shows complete work history: which Sessions have checked in to this Task, the checkin/checkout times, and the Agent's work reports. This is Chorus's observability — even with 5 Agents working simultaneously, you can clearly see what everyone is doing.</p>\n<p><strong>Pixel Office — Agent Virtual Workstations</strong></p>\n<p><img src=\"/f9e773e8262d031c6edf6ba5be789074/pixcel-workspace.gif\" alt=\"Pixel Workspace\"></p>\n<p>This is a fun feature of Chorus: each active Agent Session has its own workstation in a pixel art office. Agents start a \"working\" animation when checked in to a Task, rest when idle, and celebrate when done. Purely visual entertainment, but you can see the team's work status at a glance.</p>\n<hr>\n<h2>3. Why Build a Claude Code Plugin</h2>\n<p>Before the plugin, the Team Lead had to hand-write extensive boilerplate in every Sub-Agent's spawn prompt:</p>\n<pre><code class=\"language-python\">Task({\n  name: \"frontend-worker\",\n  prompt: \"\"\"\n    Your Chorus session UUID: ??? (Team Lead doesn't know yet — session hasn't been created)\n    Your Chorus task UUID: task-A-uuid\n\n    Before work:\n    1. Create session: chorus_create_session(...)\n    2. Checkin: chorus_session_checkin_task(sessionUuid, taskUuid)\n    3. Update status: chorus_update_task(taskUuid, \"in_progress\", sessionUuid)\n\n    During work:\n    4. Report progress: chorus_report_work(taskUuid, report, sessionUuid)\n\n    After completion:\n    5. Checkout: chorus_session_checkout_task(sessionUuid, taskUuid)\n    6. Submit for verification: chorus_submit_for_verify(taskUuid, summary)\n    7. Close session: chorus_close_session(sessionUuid)\n  \"\"\"\n})\n</code></pre>\n<p>The problems are obvious:</p>\n<ol>\n<li><strong>Session UUID can't be known in advance</strong> — Sessions require MCP calls to create, but the prompt must be written before spawn</li>\n<li><strong>Every Sub-Agent's prompt repeats the same boilerplate</strong> — 6-7 workflow steps taking up significant prompt space</li>\n<li><strong>The Team Lead must remember all the steps</strong> — Forgot checkout? Forgot heartbeat? The Session will become stale</li>\n<li><strong>Session lifecycle management is complex</strong> — Create, reuse, reopen, heartbeat, close — all manual</li>\n</ol>\n<p>With the plugin, all of this is automated:</p>\n<pre><code class=\"language-python\">Task({\n  name: \"frontend-worker\",\n  prompt: \"\"\"\n    Your Chorus task UUID: task-A-uuid\n    Implement the frontend user form component...\n  \"\"\"\n})\n</code></pre>\n<p>From 15 lines of boilerplate to 2 lines. The Team Lead only passes the task UUID — the plugin's <code>SubagentStart</code> hook automatically injects the session UUID and complete workflow instructions directly into the Sub-Agent's context. No session files to read, no workflow boilerplate to copy.</p>\n<hr>\n<h2>4. Claude Code Plugin System Overview</h2>\n<p>A Claude Code plugin is a directory containing these components:</p>\n<pre><code>my-plugin/\n├── .claude-plugin/\n│   └── plugin.json          # Plugin manifest (metadata)\n├── .mcp.json                # MCP server configuration\n├── hooks/\n│   └── hooks.json           # Hook configuration\n├── bin/                     # Hook scripts\n│   ├── on-session-start.sh\n│   └── on-subagent-start.sh\n└── skills/\n    └── my-skill/\n        ├── SKILL.md         # Skill entry file\n        └── references/      # Reference documents\n</code></pre>\n<p>Let's walk through each component.</p>\n<h3>4.1 Plugin Manifest (plugin.json)</h3>\n<p>Located at <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/.claude-plugin/plugin.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>.claude-plugin/plugin.json</code></a>, it's the plugin's identity card:</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"chorus\",\n  \"description\": \"Chorus AI-DLC collaboration platform plugin...\",\n  \"version\": \"0.1.3\",\n  \"author\": { \"name\": \"Chorus-AIDLC\" },\n  \"homepage\": \"https://github.com/Chorus-AIDLC/chorus\",\n  \"license\": \"AGPL-3.0\",\n  \"keywords\": [\"ai-dlc\", \"mcp\", \"multi-agent\", \"session\"]\n}\n</code></pre>\n<p><code>plugin.json</code> is optional — if omitted, Claude Code infers the plugin name from the directory name and auto-discovers components. But it's recommended to always provide one for version management and distribution.</p>\n<h3>4.2 Marketplace</h3>\n<p>Plugins are distributed through Marketplaces. A Marketplace is essentially a JSON manifest file (<a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/.claude-plugin/marketplace.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>.claude-plugin/marketplace.json</code></a>) hosted in a public GitHub repo. Chorus uses its own GitHub repository as a Marketplace:</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"chorus-plugins\",\n  \"owner\": { \"name\": \"Chorus-AIDLC\" },\n  \"plugins\": [\n    {\n      \"name\": \"chorus\",\n      \"source\": \"./public/chorus-plugin\",\n      \"description\": \"Chorus AI-DLC collaboration platform plugin...\",\n      \"version\": \"0.1.3\",\n      \"category\": \"project-management\",\n      \"tags\": [\"ai-dlc\", \"collaboration\", \"mcp\", \"session\"]\n    }\n  ]\n}\n</code></pre>\n<p>The actual installation flow for the Chorus plugin:</p>\n<pre><code class=\"language-bash\"># 1. Add marketplace — points to the GitHub repo (containing .claude-plugin/marketplace.json)\n/plugin marketplace add Chorus-AIDLC/chorus\n\n# 2. Install plugin — format: plugin-name@marketplace-name\n/plugin install chorus@chorus-plugins\n\n# 3. Optionally specify scope\n/plugin install chorus@chorus-plugins --scope project  # Project-level (shared with team, committed to git)\n/plugin install chorus@chorus-plugins --scope local    # Local-level (just for you)\n</code></pre>\n<p>The <code>source</code> field points to the plugin's relative path within the repo. Besides local paths, it also supports pointing to other GitHub repos (<code>\"source\": {\"source\": \"github\", \"repo\": \"owner/repo\"}</code>) or Git URLs.</p>\n<h3>4.3 MCP Configuration (<a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/.mcp.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.mcp.json</a>)</h3>\n<p>Plugins can bundle MCP Server configuration that takes effect automatically after installation:</p>\n<pre><code class=\"language-json\">{\n  \"mcpServers\": {\n    \"chorus\": {\n      \"type\": \"http\",\n      \"url\": \"${CHORUS_URL}/api/mcp\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${CHORUS_API_KEY}\"\n      }\n    }\n  }\n}\n</code></pre>\n<p><code>${CHORUS_URL}</code> and <code>${CHORUS_API_KEY}</code> are environment variables — Claude Code substitutes them at runtime. Users just need to set the environment variables, and the plugin connects to the right service.</p>\n<p>This means: <strong>after plugin installation, all MCP tools are automatically available</strong>. Sub-Agents can access them too (provided MCP config is at the project level, not user level).</p>\n<p><strong>Chorus's MCP Configuration</strong>: Chorus exposes 50+ MCP tools via HTTP Streamable Transport, grouped by role (public tools, PM tools, Developer tools, Admin tools, Session tools). Users only need to set two environment variables <code>CHORUS_URL</code> and <code>CHORUS_API_KEY</code> to connect. API Keys start with the <code>cho_</code> prefix and carry Agent role information — the server determines which tools are visible based on this.</p>\n<h3>4.4 Skills</h3>\n<p>Skills are plugin-bundled instruction sets that Claude can invoke automatically when needed, or users can trigger manually via <code>/skill-name</code>.</p>\n<p>A Skill consists of a <code>SKILL.md</code> entry file and optional <code>references/</code> documents:</p>\n<pre><code class=\"language-markdown\">---\nname: chorus\ndescription: Chorus AI Agent collaboration platform Skill...\nmetadata:\n  author: chorus\n  version: \"0.1.1\"\n  category: project-management\n  mcp_server: chorus\n---\n\n# Chorus Skill\n\nThis Skill guides AI Agents on how to use Chorus MCP tools...\n\n## Skill Files\n\n| File | Description |\n|------|-------------|\n| **references/02-pm-workflow.md** | PM Agent workflow |\n| **references/03-developer-workflow.md** | Developer Agent workflow |\n| **references/06-claude-code-agent-teams.md** | Agent Teams integration |\n</code></pre>\n<p><strong>Chorus's Skill System</strong>: Chorus includes <a href=\"https://github.com/Chorus-AIDLC/Chorus/tree/main/public/chorus-plugin/skills/chorus/references\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">7 reference documents</a> (<code>references/00</code> through <code>references/06</code>), covering everything from public tools, PM workflow, Developer workflow, Admin workflow, to Session management and Agent Teams integration. When an Agent invokes <code>/chorus</code> or Claude determines Chorus knowledge is needed, Skill docs are automatically loaded into context. This is essentially giving every Agent a portable operations manual — whether it's the Team Lead or a Sub-Agent, they can understand the correct workflow through Skills.</p>\n<p>Skill frontmatter supports rich configuration options:</p>\n<pre><code class=\"language-yaml\">---\nname: my-skill\ndescription: \"When to use this skill\"\nallowed-tools: Read, Grep, Glob     # Tools allowed without permission prompts\nmodel: claude-opus-4-6              # Specify model\ncontext: fork                       # Run in subagent\ndisable-model-invocation: true      # Only user can trigger (Claude won't auto-invoke)\n---\n</code></pre>\n<h3>4.5 Hooks</h3>\n<p>Hooks are the core of plugins — they let you execute custom logic at key points in Claude Code's lifecycle.</p>\n<p>Configured in <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/hooks/hooks.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>hooks/hooks.json</code></a>:</p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"SessionStart\": [{\n      \"matcher\": \"startup|resume|compact\",\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/on-session-start.sh\"\n      }]\n    }],\n    \"SubagentStart\": [{\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/on-subagent-start.sh\"\n      }]\n    }],\n    \"SubagentStop\": [{\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/on-subagent-stop.sh\",\n        \"async\": true\n      }]\n    }]\n  }\n}\n</code></pre>\n<h4>Hook Types</h4>\n<p>Claude Code supports three hook execution methods:</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Description</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>command</code></td>\n<td>Execute a shell command, receiving event JSON via stdin, outputting results via stdout</td>\n<td>Most scenarios</td>\n</tr>\n<tr>\n<td><code>prompt</code></td>\n<td>Use an LLM to evaluate decisions, model returns <code>{ok: true/false}</code></td>\n<td>When intelligent judgment is needed (e.g., code review)</td>\n</tr>\n<tr>\n<td><code>agent</code></td>\n<td>Spawn a subagent with tool access for verification</td>\n<td>When complex multi-step verification is needed (e.g., running tests)</td>\n</tr>\n</tbody>\n</table>\n<p>All of Chorus's hooks use the <code>command</code> type — because Chorus's hook logic is deterministic (calling APIs, reading/writing files, managing state) and doesn't require LLM judgment. <code>prompt</code> and <code>agent</code> are better suited for scenarios that require \"understanding\" code content to make decisions, such as using an <code>agent</code> type in the <code>Stop</code> event to automatically run tests to determine if a task is truly complete.</p>\n<h4>Hook Event Reference</h4>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>When Triggered</th>\n<th>Can Block</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>SessionStart</code></td>\n<td>Session start/resume/compact</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>UserPromptSubmit</code></td>\n<td>User submits input</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>PreToolUse</code></td>\n<td>Before tool execution</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>PostToolUse</code></td>\n<td>After tool execution</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>SubagentStart</code></td>\n<td>Sub-Agent starts</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>SubagentStop</code></td>\n<td>Sub-Agent exits</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>TeammateIdle</code></td>\n<td>Sub-Agent goes idle</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>TaskCompleted</code></td>\n<td>CC Task completed</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>SessionEnd</code></td>\n<td>Session ends</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<h4>Hook Output Format</h4>\n<p>Now that we know what events are available, the next question is: <strong>what can a hook script return to influence Claude's behavior?</strong> Hooks output JSON via stdout:</p>\n<pre><code class=\"language-json\">{\n  \"systemMessage\": \"User-visible notification message\",\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SubagentStart\",\n    \"additionalContext\": \"This text is injected into Claude's context\",\n    \"permissionDecision\": \"allow\"\n  }\n}\n</code></pre>\n<p>Key fields:</p>\n<ul>\n<li><strong><code>systemMessage</code></strong>: Displayed in the Claude Code UI as a notification, visible to users</li>\n<li><strong><code>additionalContext</code></strong>: Injected into the LLM's system context — <strong>this is the primary mechanism for hooks to influence Claude's behavior</strong>. Chorus's <code>SessionStart</code> hook uses it to inject checkin results (identity, tasks, notifications) into the Agent's context</li>\n<li><strong><code>permissionDecision</code></strong>: <code>allow</code> / <code>deny</code> / <code>ask</code>, used by <code>PreToolUse</code> to control tool execution permissions</li>\n<li><strong><code>suppressOutput</code></strong>: Set to <code>true</code> to silence output — Chorus's <code>TeammateIdle</code> hook uses this to avoid notification popups on every heartbeat</li>\n</ul>\n<h4>Synchronous vs Asynchronous</h4>\n<ul>\n<li><strong>Synchronous hooks</strong> (default): Block Claude until completion. Suited for scenarios requiring immediate effect — Chorus's <code>SubagentStart</code> must be synchronous because it needs to create the session and write the session file before the Sub-Agent starts working</li>\n<li><strong>Asynchronous hooks</strong> (<code>\"async\": true</code>): Run in background, non-blocking. Suited for scenarios that don't affect the flow — Chorus's <code>SubagentStop</code> (resource cleanup) and <code>TeammateIdle</code> (heartbeat) are both asynchronous</li>\n</ul>\n<h4>What Chorus Does with Each Hook Event</h4>\n<p>Now that we understand events, output format, and sync/async, let's see how the Chorus plugin specifically uses each hook.</p>\n<p><strong><code>SessionStart</code> — Checkin + Context Injection</strong></p>\n<p>This is the plugin's \"startup self-check\". Note that the <code>SessionStart</code> matcher is configured as <code>startup|resume|compact</code>, meaning it fires not only on session start and resume, but <strong>also after context compaction</strong>. When a long conversation triggers automatic compaction, previously injected Chorus context is lost along with the compressed messages — the <code>compact</code> matcher ensures that fresh checkin information is re-injected immediately after compaction, so the Agent never \"forgets\" its Chorus context.</p>\n<p>Chorus does three things here:</p>\n<ol>\n<li>Calls the <code>chorus_checkin()</code> MCP tool to get the current Agent's identity (role, name, persona), assigned Ideas and Tasks, and unread notifications</li>\n<li>Injects the complete checkin result into Claude's context via <code>additionalContext</code> — the Agent knows who it is and what to do from the very first turn</li>\n<li>Scans the <code>.chorus/sessions/</code> directory to list existing Sub-Agent session metadata — this handles the case where a Claude Code session is interrupted and resumed: previous session files may still exist, and the Team Lead needs to know which sessions are still present after recovery</li>\n</ol>\n<pre><code class=\"language-bash\"># on-session-start.sh core logic\nCHECKIN_RESULT=$(\"$API\" mcp-tool \"chorus_checkin\" '{}')\n\nCONTEXT=\"# Chorus Plugin — Active\nChorus is connected at ${CHORUS_URL}.\n## Checkin Result\n${CHECKIN_RESULT}\n## Session Management — IMPORTANT\nThe Chorus Plugin fully automates session lifecycle...\nDo NOT call chorus_create_session for sub-agents.\"\n\n\"$API\" hook-output \"$USER_MSG\" \"$CONTEXT\" \"SessionStart\"\n</code></pre>\n<p>Result: The Agent has complete project context and behavioral guidelines from its very first conversation turn, without the user having to manually provide anything.</p>\n<p><strong><code>UserPromptSubmit</code> — Lightweight Status Reminder</strong></p>\n<p>Triggered on every user input, so it must be extremely fast (&#x3C;100ms). Chorus makes <strong>no network calls</strong> here, only local file checks:</p>\n<pre><code class=\"language-bash\"># on-user-prompt.sh — pure local operation, no MCP calls\n# Count json files in .chorus/sessions/\nCONTEXT=\"[Chorus Plugin Active]\n- Active sub-agent sessions (3): frontend-worker, backend-worker, test-runner\"\n</code></pre>\n<p>This gives the Team Lead persistent status awareness: how many Sub-Agent sessions are currently running.</p>\n<p><strong><code>PreToolUse</code> — Workflow Guidance (3 Sub-Hooks)</strong></p>\n<p>Chorus registers 3 <code>PreToolUse</code> hooks, each matching a different tool:</p>\n<table>\n<thead>\n<tr>\n<th>matcher</th>\n<th>Script</th>\n<th>What Chorus Does</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>EnterPlanMode</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-enter-plan.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>on-pre-enter-plan.sh</code></a></td>\n<td>Inject Chorus Proposal workflow guidance — \"Create a Proposal first, set up Task dependency DAG, submit for approval before coding\"</td>\n</tr>\n<tr>\n<td><code>ExitPlanMode</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-exit-plan.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>on-pre-exit-plan.sh</code></a></td>\n<td>Reminder check — \"Confirm Proposal has been created and submitted before exiting Plan Mode\"</td>\n</tr>\n<tr>\n<td><code>Task</code></td>\n<td><a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-pre-spawn-agent.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>on-pre-spawn-agent.sh</code></a></td>\n<td>Capture Sub-Agent name/type to pending file for SubagentStart to claim</td>\n</tr>\n</tbody>\n</table>\n<p><code>EnterPlanMode</code> and <code>ExitPlanMode</code> demonstrate an interesting usage: <strong>using hooks to guide Agents toward following a specific workflow</strong>. When the Agent enters Plan Mode, Chorus automatically injects \"create Proposal before coding\" guidance; when exiting Plan Mode, it checks whether a Proposal exists. This isn't a hard block (<code>permissionDecision</code> remains <code>allow</code>), but soft guidance via <code>additionalContext</code>.</p>\n<p><strong><code>SubagentStart</code> — Automatic Session Creation + Direct Context Injection</strong> (Core)</p>\n<p>This is the Chorus plugin's most critical hook, detailed in Chapter 5. In brief: claim pending file → create/reuse Session → inject session UUID + workflow instructions directly into Sub-Agent's context via <code>additionalContext</code> → store state mappings. The session file is kept minimal (just metadata for other hooks).</p>\n<p><strong><code>SubagentStop</code> — Automatic Cleanup + Task Discovery</strong></p>\n<p>Runs asynchronously, doing four things: (1) batch checkout all unclosed task checkins, (2) close the Session, (3) clean up local files and state, (4) query the project for newly unblocked Tasks and notify the Team Lead via <code>additionalContext</code> — this last step is extremely valuable, implementing <strong>automatic task dispatch discovery</strong>: when an upstream Task completes, downstream Tasks automatically become unblocked, and the Team Lead is immediately notified to assign new work.</p>\n<p><strong><code>TeammateIdle</code> — Automatic Heartbeat</strong></p>\n<p>Async + <code>suppressOutput: true</code>. Does just one thing: calls <code>chorus_session_heartbeat</code> to keep the Session active. Chorus Sessions are automatically marked as inactive after 1 hour without a heartbeat — this hook ensures that as long as a Sub-Agent is running, its Session stays alive.</p>\n<p><strong><code>TaskCompleted</code> — Metadata Bridging</strong></p>\n<p>When a Claude Code internal Task is marked complete, Chorus checks whether the task description contains a <code>chorus:task:&#x3C;uuid></code> tag. If so, it automatically executes <code>chorus_session_checkout_task</code>. This is an elegant <strong>metadata bridging</strong> pattern — by embedding a Chorus task UUID in the CC Task description, the two systems' Task lifecycles are linked.</p>\n<p><strong><code>SessionEnd</code> — Clean Up .chorus/ Directory</strong></p>\n<p>When the session ends, checks whether all session files have been cleaned up and state.json is empty. If so, deletes the entire <code>.chorus/</code> directory, leaving no leftover files.</p>\n<hr>\n<h2>5. Chorus Plugin: Complete Implementation</h2>\n<p>Now for the main topic — how the Chorus plugin uses the above mechanisms to solve multi-agent collaboration problems.</p>\n<h3>5.1 Architecture Overview</h3>\n<pre><code>Team Lead calls Task tool to spawn Sub-Agent\n  │\n  ├─ [PreToolUse:Task] on-pre-spawn-agent.sh\n  │    Write .chorus/pending/&#x3C;name> file (capture agent name)\n  │\n  ├─ [SubagentStart] on-subagent-start.sh    ← Core\n  │    Claim pending file (atomic mv, handles concurrency)\n  │    Create/reuse/reopen Chorus Session (MCP call)\n  │    Inject session UUID + workflow into Sub-Agent via additionalContext\n  │    Write minimal session file (metadata for other hooks)\n  │    Store state mappings (agent_id ↔ session_uuid)\n  │\n  ├─ Sub-Agent starts executing\n  │    Session UUID + workflow already in context (auto-injected)\n  │    Autonomously execute: checkin → in_progress → report → checkout → submit\n  │\n  ├─ [TeammateIdle] on-teammate-idle.sh (async)\n  │    Send session heartbeat, keep session active\n  │\n  ├─ [TaskCompleted] on-task-completed.sh\n  │    Detect chorus:task:&#x3C;uuid> tag, auto checkout\n  │\n  └─ [SubagentStop] on-subagent-stop.sh (async)\n       Batch checkout all tasks\n       Close Chorus Session\n       Clean up local state\n       Query and display newly unblocked tasks\n</code></pre>\n<h3>5.2 The <code>.chorus/</code> Directory: The Bridge Connecting Everything</h3>\n<p>We've mentioned \"shared filesystem\" multiple times — let's expand on this. The Chorus plugin maintains a <code>.chorus/</code> directory (gitignored) at the project root, serving as the information hub between the Team Lead, Sub-Agents, and all hooks:</p>\n<pre><code>.chorus/                              # Plugin runtime state (gitignored)\n├── state.json                        # Global state KV store\n├── state.json.lock                   # flock exclusive lock file\n├── sessions/                         # Sub-Agent session metadata (for hook state lookup)\n│   ├── frontend-worker.json\n│   ├── backend-worker.json\n│   └── test-runner.json\n├── pending/                          # Written by PreToolUse:Task, awaiting SubagentStart claim\n│   └── &#x3C;agent-name>\n└── claimed/                          # Files claimed by SubagentStart\n    └── &#x3C;agent-id>\n</code></pre>\n<h4>Core: <code>state.json</code> — Cross-Hook State Sharing</h4>\n<p>Each hook is an independent shell process — they don't share memory. <code>state.json</code> is the shared state store across all hooks:</p>\n<pre><code class=\"language-json\">{\n  \"session_a0ed860\": \"699f8ed4-4a98-4522-8321-662a2222a180\",\n  \"agent_for_session_699f8ed4-...\": \"a0ed860\",\n  \"session_frontend-worker\": \"699f8ed4-...\",\n  \"name_for_agent_a0ed860\": \"frontend-worker\",\n  \"main_session_uuid\": \"...\"\n}\n</code></pre>\n<p>It stores four mapping relationships: <code>agent_id → session_uuid</code>, <code>session_uuid → agent_id</code>, <code>agent_name → session_uuid</code>, <code>agent_id → agent_name</code>. This way, any hook that knows one ID can look up all associated information.</p>\n<h4>Concurrent Write Protection: flock</h4>\n<p>When 5 Sub-Agents spawn simultaneously, 5 <code>SubagentStart</code> hooks execute concurrently, each writing 4 keys to <code>state.json</code>. Without protection, the JSON file would be corrupted by concurrent writes.</p>\n<p>Chorus solves this in <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/chorus-api.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>chorus-api.sh</code></a> using <code>flock</code> exclusive locks:</p>\n<pre><code class=\"language-bash\"># state_set implementation in chorus-api.sh\nstate_set() {\n  local key=\"$1\" value=\"$2\"\n  (\n    # Acquire exclusive lock, 5-second timeout\n    flock -w 5 200 || { echo \"WARN: flock timeout\" >&#x26;2; return 0; }\n    # Modify JSON under lock protection\n    jq --arg k \"$key\" --arg v \"$value\" '.[$k] = $v' \"$STATE_FILE\" > \"$tmp\" \\\n      &#x26;&#x26; mv \"$tmp\" \"$STATE_FILE\"\n  ) 200>\"${STATE_FILE}.lock\"\n}\n</code></pre>\n<p>Key details:</p>\n<ul>\n<li><code>flock -w 5 200</code>: Acquire exclusive lock on file descriptor 200, wait up to 5 seconds</li>\n<li><code>200>\"${STATE_FILE}.lock\"</code>: Lock file is separate from the state file (<code>.lock</code> suffix)</li>\n<li><code>jq ... > $tmp &#x26;&#x26; mv $tmp</code>: Write to temp file first, then atomically replace — prevents corruption if a crash happens mid-write</li>\n<li>Timeout doesn't error (<code>return 0</code>) — better to lose one state write than block the entire hook chain</li>\n</ul>\n<h4><code>pending/</code> → <code>claimed/</code>: Atomic Ownership Transfer</h4>\n<p>The <code>SubagentStart</code> event only provides <code>agent_id</code> and <code>agent_type</code>, <strong>not the name the Team Lead gave the Sub-Agent</strong>. But sessions need to be named (so the Sub-Agent can find its session file by name).</p>\n<p>The solution is a relay between two hooks:</p>\n<ol>\n<li><code>PreToolUse:Task</code> (Team Lead context) can extract the <code>name</code> parameter from <code>tool_input</code>, writing it to a <code>pending/&#x3C;name></code> file</li>\n<li><code>SubagentStart</code> (still Team Lead context, but executing concurrently) atomically claims it via <code>mv pending/&#x3C;name> claimed/&#x3C;agent_id></code></li>\n</ol>\n<pre><code>Timeline:\n  T1  PreToolUse:Task fires → write .chorus/pending/frontend-worker\n  T2  PreToolUse:Task fires → write .chorus/pending/backend-worker\n  T3  SubagentStart(agent_id=a0e) fires → mv pending/frontend-worker → claimed/a0e ✓\n  T4  SubagentStart(agent_id=b1f) fires → mv pending/backend-worker → claimed/b1f ✓\n  T4' SubagentStart(agent_id=c2g) fires → mv pending/frontend-worker → fails (already claimed by a0e)\n                                        → mv pending/backend-worker → fails (already claimed by b1f)\n                                        → no more pending files → skip (internal agent, no session needed)\n</code></pre>\n<p><code>mv</code> is atomic on the same filesystem — only one process can successfully move a given file. This is lighter than flock, well-suited for \"first come, first served\" scenarios.</p>\n<h4><code>sessions/</code> — Metadata for Cross-Hook State Lookup</h4>\n<p>Session files now contain only minimal metadata (sessionUuid, agentId, agentName). Workflow instructions are injected directly into the Sub-Agent's context via <code>SubagentStart</code>'s <code>additionalContext</code> — Sub-Agents no longer need to read these files. The files still serve a purpose: other hooks (<code>TeammateIdle</code>, <code>SubagentStop</code>) use them to look up session information for heartbeats and cleanup.</p>\n<h4>Lifecycle: Creation to Cleanup</h4>\n<pre><code>SessionStart  → mkdir -p .chorus/ (if not exists)\nPreToolUse    → write .chorus/pending/&#x3C;name>\nSubagentStart → mv pending → claimed, write sessions/&#x3C;name>.json (metadata only),\n                inject workflow via additionalContext → Sub-Agent, update state.json\nTeammateIdle  → read state.json (lookup session_uuid), no writes\nTaskCompleted → read state.json (lookup session_uuid), no writes\nSubagentStop  → delete sessions/&#x3C;name>.json, delete claimed/&#x3C;agent_id>, clean state.json entries\nSessionEnd    → if sessions/ is empty and state.json is empty → rm -rf .chorus/\n</code></pre>\n<p>The entire directory's lifecycle matches the Claude Code session — created at start, cleaned up at end, leaving no trace.</p>\n<h3>5.3 The Core Challenge: Sub-Agent Context Injection</h3>\n<p>The key question is: how do you automatically provide each Sub-Agent with its session UUID and workflow instructions, without the Team Lead hand-writing boilerplate?</p>\n<p>The answer lies in a critical property of the <code>SubagentStart</code> hook: <strong>its <code>additionalContext</code> is injected directly into the Sub-Agent's context</strong>, not the Team Lead's. This makes it the ideal injection point — the hook that creates the session (and thus knows the sessionUuid) can also inject the workflow, all in one place.</p>\n<pre><code class=\"language-bash\"># on-subagent-start.sh — core snippet\n# After creating/reusing a session and obtaining SESSION_UUID...\n\nWORKFLOW=\"## Chorus Session (Auto-injected by plugin)\n\nYour Chorus session UUID is: ${SESSION_UUID}\nYour session name is: ${SESSION_NAME}\nDo NOT call chorus_create_session or chorus_close_session.\n\n### Workflow — follow these steps for each task:\n\n**Before starting:**\n1. Check in: chorus_session_checkin_task({ sessionUuid: \\\"${SESSION_UUID}\\\", taskUuid: \\\"&#x3C;TASK_UUID>\\\" })\n2. Start work: chorus_update_task({ taskUuid: \\\"&#x3C;TASK_UUID>\\\", status: \\\"in_progress\\\", sessionUuid: \\\"${SESSION_UUID}\\\" })\n\n**While working:**\n3. Report progress: chorus_report_work({ taskUuid: \\\"&#x3C;TASK_UUID>\\\", report: \\\"...\\\", sessionUuid: \\\"${SESSION_UUID}\\\" })\n\n**After completing:**\n4. Check out: chorus_session_checkout_task({ sessionUuid: \\\"${SESSION_UUID}\\\", taskUuid: \\\"&#x3C;TASK_UUID>\\\" })\n5. Submit: chorus_submit_for_verify({ taskUuid: \\\"&#x3C;TASK_UUID>\\\", summary: \\\"...\\\" })\n\nReplace &#x3C;TASK_UUID> with the actual Chorus task UUID from your prompt.\"\n\n\"$API\" hook-output \\\n  \"Chorus session ${SESSION_ACTION}: '${SESSION_NAME}'\" \\\n  \"$WORKFLOW\" \\\n  \"SubagentStart\"\n</code></pre>\n<p>The Sub-Agent sees the workflow as a <code>&#x3C;system-reminder></code> in its context from the very first turn. The session file is kept minimal (just sessionUuid + metadata) for other hooks to use.</p>\n<p>This means the Team Lead's spawn prompt is truly minimal:</p>\n<pre><code class=\"language-python\">Task({\n  name: \"frontend-worker\",\n  prompt: \"\"\"\n    Your Chorus task UUID: task-A-uuid\n    Implement the frontend user form component...\n  \"\"\"\n})\n</code></pre>\n<p>The plugin handles everything else — the Team Lead only passes the task UUID.</p>\n<h3>5.4 Session Reuse: Avoiding Duplicate Creation</h3>\n<p>When the Team Lead spawns a Sub-Agent with the same name multiple times (e.g., after a Task is reopened by Admin), the plugin doesn't create a new Session — it reuses the existing one:</p>\n<pre><code class=\"language-bash\"># Reuse logic in on-subagent-start.sh\nif [ \"$MATCH_STATUS\" = \"active\" ]; then\n    SESSION_UUID=\"$MATCH_UUID\"         # Reuse directly\n    SESSION_ACTION=\"reused\"\nelif [ \"$MATCH_STATUS\" = \"closed\" ] || [ \"$MATCH_STATUS\" = \"inactive\" ]; then\n    # Reopen closed session\n    chorus_reopen_session(sessionUuid)\n    SESSION_ACTION=\"reopened\"\nelse\n    # Create new session\n    chorus_create_session(name)\n    SESSION_ACTION=\"created\"\nfi\n</code></pre>\n<h3>5.5 Automatic Cleanup: SubagentStop</h3>\n<p>When a Sub-Agent exits, <a href=\"https://github.com/Chorus-AIDLC/Chorus/blob/main/public/chorus-plugin/bin/on-subagent-stop.sh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>on-subagent-stop.sh</code></a> (running asynchronously) handles cleanup:</p>\n<ol>\n<li>Query all active checkins for the Session, checkout each one</li>\n<li>Close the Chorus Session</li>\n<li>Delete local state (state entries, session file, claimed file)</li>\n<li>Query the project for newly unblocked Tasks and notify the Team Lead</li>\n</ol>\n<p>This way, even if a Sub-Agent forgot to checkout or close its session, the plugin provides a safety net.</p>\n<h3>5.6 Automatic Heartbeat: TeammateIdle</h3>\n<p>Sub-Agents enter an idle state between conversation turns, at which point the <code>TeammateIdle</code> hook automatically sends a heartbeat:</p>\n<pre><code class=\"language-bash\"># on-teammate-idle.sh\n\"$API\" mcp-tool \"chorus_session_heartbeat\" \\\n  \"$(printf '{\"sessionUuid\":\"%s\"}' \"$SESSION_UUID\")\"\n</code></pre>\n<p>Output is silenced with <code>suppressOutput: true</code> — heartbeats are too frequent to warrant notifying the Team Lead.</p>\n<hr>\n<h2>6. Design Pattern Summary</h2>\n<p>From the Chorus plugin's practice, we can extract several reusable design patterns:</p>\n<h3>Pattern 1: SubagentStart for Direct Context Injection</h3>\n<pre><code>SubagentStart hook  →  additionalContext  →  Sub-Agent's context\n(has session data)      (direct injection)    (sees it immediately)\n</code></pre>\n<p><code>SubagentStart</code>'s <code>additionalContext</code> is the most reliable way to inject context into Sub-Agents. It fires synchronously at spawn time, has access to all session data, and injects directly into the Sub-Agent — no file reading, no prompt manipulation, no Team Lead involvement required.</p>\n<h3>Pattern 2: Filesystem for Cross-Hook State (Not Sub-Agent Communication)</h3>\n<p>The shared filesystem (<code>.chorus/</code> directory) is valuable for <strong>hook-to-hook</strong> state passing (e.g., <code>pending/</code> files relay agent names from <code>PreToolUse</code> to <code>SubagentStart</code>), but should not be the primary mechanism for Sub-Agent context injection. Use <code>SubagentStart</code>'s <code>additionalContext</code> for that instead.</p>\n<h3>Pattern 3: PreToolUse Captures + SubagentStart Executes</h3>\n<p>The <code>SubagentStart</code> event doesn't provide the Sub-Agent's name (only <code>agent_id</code> and <code>agent_type</code>), but <code>PreToolUse:Task</code> can extract it from <code>tool_input</code>. The two hooks pass information via the filesystem (pending → claimed).</p>\n<h3>Pattern 4: Async Hooks for Non-Blocking Cleanup</h3>\n<p>Session closing, resource cleanup, notifications, and other operations that don't affect the flow should go in async hooks. Don't let cleanup logic block a Sub-Agent's exit.</p>\n<h3>Pattern 5: Hooks Suggest, Don't Enforce</h3>\n<p><code>PreToolUse:Task</code> injects a reminder to the Team Lead (\"remember to include task UUID in the prompt\"), but doesn't block the operation. In team collaboration, <strong>suggestions over enforcement</strong> — overly strict hooks degrade the user experience.</p>\n<hr>\n<h2>7. Quick Start: Building Your Own Plugin</h2>\n<p>If you want to build a Claude Code plugin for your own toolchain, here are the minimum viable steps:</p>\n<h3>Step 1: Create Directory Structure</h3>\n<pre><code class=\"language-bash\">mkdir -p my-plugin/.claude-plugin my-plugin/hooks my-plugin/bin\n</code></pre>\n<h3>Step 2: Write plugin.json</h3>\n<pre><code class=\"language-json\">{\n  \"name\": \"my-plugin\",\n  \"description\": \"My custom plugin for Claude Code\",\n  \"version\": \"0.1.0\"\n}\n</code></pre>\n<h3>Step 3: Write Your First Hook</h3>\n<p><code>hooks/hooks.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"hooks\": {\n    \"SessionStart\": [{\n      \"matcher\": \"startup\",\n      \"hooks\": [{\n        \"type\": \"command\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/bin/on-start.sh\"\n      }]\n    }]\n  }\n}\n</code></pre>\n<p><code>bin/on-start.sh</code>:</p>\n<pre><code class=\"language-bash\">#!/usr/bin/env bash\nset -euo pipefail\n\ncat &#x3C;&#x3C;EOF\n{\n  \"systemMessage\": \"My plugin is active!\",\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"SessionStart\",\n    \"additionalContext\": \"My Plugin is connected. Custom workflow instructions here.\"\n  }\n}\nEOF\n</code></pre>\n<h3>Step 4: Test Locally</h3>\n<pre><code class=\"language-bash\">chmod +x my-plugin/bin/on-start.sh\nclaude --plugin-dir ./my-plugin\n</code></pre>\n<h3>Step 5: Publish to Marketplace</h3>\n<p>Create <code>.claude-plugin/marketplace.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"name\": \"my-marketplace\",\n  \"owner\": { \"name\": \"Your Name\" },\n  \"plugins\": [{\n    \"name\": \"my-plugin\",\n    \"source\": \"./my-plugin\",\n    \"version\": \"0.1.0\"\n  }]\n}\n</code></pre>\n<hr>\n<h2>Closing Thoughts</h2>\n<p>Claude Code's plugin system provides a complete extension mechanism — from Marketplace distribution, to MCP tool integration, to Hooks lifecycle management, to Skills knowledge injection. The introduction of Agent Teams (Swarm mode) makes multi-agent collaboration possible, and plugins make that collaboration manageable and observable.</p>\n<p>The Chorus plugin's practice demonstrates that <code>SubagentStart</code>'s <code>additionalContext</code> — which injects directly into the Sub-Agent's context — is the key to seamless multi-agent workflow automation. Combined with the shared filesystem for cross-hook state management and <code>PreToolUse</code> for capturing spawn-time metadata, a fully automated session lifecycle can be achieved with zero boilerplate in the Team Lead's prompts.</p>\n<p>If you're interested in Chorus, visit <a href=\"https://github.com/Chorus-AIDLC/chorus\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub</a> to learn more. If you're building your own Claude Code plugin, we hope this article's experience helps you avoid some pitfalls.</p>","excerpt":"Based on real-world development experience from the Chorus project, this article systematically introduces Claude Code's plugin mechanism, with a focus on building plugins for Agent Teams (Swarm mode) and solving the context injection challenge in…","frontmatter":{"date":"February 21, 2025","path":"/building-claude-code-plugin-for-agent-teams","title":"Building Plugins for Claude Code Agent Teams: Design Patterns from the Chorus Experience"}}},"pageContext":{}},"staticQueryHashes":["2560569871","3584596544","63159454"],"slicesMap":{}}