{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/lima-alternative-docker-desktop-for-mac","result":{"data":{"markdownRemark":{"html":"<p>在2021年8月31日，Docker官方发布了一条<a href=\"https://www.docker.com/blog/updating-product-subscriptions/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">博客</a>表明了Docker desktop即将进入订阅收费制模式，并给了一段缓冲期至到2022年1月31日。这也意味着从2022年2月1日开始，所有将Docker用于商业目的，公司规模大于250人或者年收大于一千万美元的公司必须缴纳订阅费用了。虽然个人，非盈利组织和教育机构并不会被收费，但除了Docker desktop之外，还有没有一个适用于Mac平台的容器解决方案以便于日常的开发工作呢？</p>\n<p>得益于Linux内核对于Namespace与Cgroup的支持，容器技术在这几年飞速发展，不仅仅构建了云原生帝国，更使程序员们在本地开发时能方便地启动服务。而如果你开发用的电脑是运行MacOS，那么想在本地环境使用Docker，要么使用虚拟机，要么就只能用官方的Docker desktop for mac了。本质上Docker desktop for mac也是将docker启动在了一层虚拟机中，并在命令行提供了几乎与Linux一致的使用体验，甚至也加入了单机Kubernetes的支持。</p>\n<p>那么一款合格的Docker desktop for Mac的\"平替\"，至少要满足以下的需求:</p>\n<ul>\n<li>在原生Mac系统中提供与Docker命令相兼容的的CLI工具</li>\n<li>在Mac系统中开启一个虚拟机，并在内部运行容器</li>\n<li>支持docker-compose</li>\n</ul>\n<p>而Kubernetes相关的功能一来不是每个人都用得到，二来诸如<a href=\"https://kind.sigs.k8s.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kind</a>以及<a href=\"https://k3s.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">K3S</a>等解决方案也足够优秀，并不需要容器解决方案来支持。这些解决方案中既有大名鼎鼎的<a href=\"https://podman.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Podman</a>，也有专为MacOS而生的<a href=\"https://github.com/lima-vm/lima\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Lima</a>&#x26;<a href=\"https://github.com/containerd/nerdctl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nerdctl</a>，今天我们一起来了解一下这个后起之秀Lima。</p>\n<h1>1.安装与启动Lima</h1>\n<p>在MacOS下安装Lima相当简单:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">brew install lima</code></pre></div>\n<p>Lima本质上是一个基于<a href=\"https://www.qemu.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">QEMU</a>的Linux虚拟机解决方案，所以我们需要先启动Lima虚拟机。这里需要注意的是默认镜像启动时需要安装一些依赖，如果你在国内可能有一些包下载缓慢或者无法下载，建议挂上代理(Lima默认配置下会把命令行中配置好的代理直接forward至虚拟机中)或者更换镜像/使用Lima配置中的<code class=\"language-text\">provision</code>项添加国内源</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">http_proxy</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>your proxy url<span class=\"token operator\">></span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">https_proxy</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>your proxy url<span class=\"token operator\">></span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">no_proxy</span><span class=\"token operator\">=</span><span class=\"token string\">\"localhost\"</span>\nlimactl start default</code></pre></div>\n<p>第一次启动虚拟机会让你选择是否要用默认的配置来启动虚拟机，可以选择(1)使用默认配置，也可以选择(2)修改配置。Lima所使用的的配置是一个yaml格式的文件，内容包含了镜像，资源限制，挂载方法等等。默认下，Lima会以只读形式将整个用户的<code class=\"language-text\">$HOME</code>目录挂载到虚拟机中，在启动容器的时候如果想挂载主机文件，也只间接从虚拟机挂载的。这就意味着默认配置下Lima内部启动的容器对宿主机的文件系统只有只读权限。为了使容器可以读写宿主机文件，需要修改Lima的配置<code class=\"language-text\">mounts</code>下<code class=\"language-text\">~</code>这一项的<code class=\"language-text\">writable</code>为true:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">mounts</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">location</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"~\"</span>\n  <span class=\"token comment\"># CAUTION: `writable` SHOULD be false for the home directory.</span>\n  <span class=\"token comment\"># Setting `writable` to true is possible, but untested and dangerous.</span>\n  <span class=\"token comment\"># Default: false</span>\n  <span class=\"token key atrule\">writable</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></code></pre></div>\n<p>也可以在mounts下添加其他想挂载的宿主机目录。</p>\n<p>在虚拟机启动过程中如果想看log，可以从这里找到:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">tail</span> -f ~/.lima/default/serial.log</code></pre></div>\n<p>在虚拟机启动完毕之后，可以直接使用<code class=\"language-text\">nerdctl</code>运行一个容器:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">lima nerdctl run --rm -it hello-world</code></pre></div>\n<p>一切正常的话你会看到输出:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker.io/library/hello-world:latest:                                             resolved       |++++++++++++++++++++++++++++++++++++++|\nindex-sha256:975f4b14f326b05db86e16de00144f9c12257553bba9484fed41f9b6f2257800:    done           |++++++++++++++++++++++++++++++++++++++|\nmanifest-sha256:f54a58bc1aac5ea1a25d796ae155dc228b3f0e11d046ae276b39c4bf2f13d8c4: done           |++++++++++++++++++++++++++++++++++++++|\nconfig-sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412:   done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:2db29710123e3e53a794f2694094b9b4338aa9ee5c40b930cb8063a1be392c54:    done           |++++++++++++++++++++++++++++++++++++++|\nelapsed: 17.1s                                                                    total:  4.4 Ki (266.0 B/s)\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/</code></pre></div>\n<h1>2.替换Docker desktop</h1>\n<p>虽然直接将<code class=\"language-text\">docker</code>和<code class=\"language-text\">docker-compose</code> alias成对应的Lima命令就可以了，但我们经常会在<code class=\"language-text\">makefile</code>或者<code class=\"language-text\">package.json</code>这些文件中直接编写调用docker命令的脚本，而alias一般只在交互式命令行起作用，也就意味着想完全替换docker的命令需要另辟蹊径了。</p>\n<p>首先我们在Lima的文件夹下创建一个<code class=\"language-text\">bin</code>文件夹用来存放脚本</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> ~/.lima/bin</code></pre></div>\n<p>然后在这个文件夹中创建两个文件</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#!/usr/bin/env bash</span>\n<span class=\"token comment\"># ~/.lima/bin/docker</span>\nlima nerdctl <span class=\"token variable\">$@</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#!/usr/bin/env bash</span>\n<span class=\"token comment\"># ~/.lima/bin/docker-compose</span>\nlima nerdctl compose <span class=\"token variable\">$@</span></code></pre></div>\n<p>将这两个文件配置为可执行</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x ~/.lima/bin/docker ~/.lima/bin/docker-compose</code></pre></div>\n<p>最后，在你的<code class=\"language-text\">~/.bashrc</code>或者<code class=\"language-text\">~/.zshrc</code>中把这个文件夹加入PATH</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token environment constant\">$HOME</span>/.lima/bin:<span class=\"token environment constant\">$PATH</span></code></pre></div>\n<p>重新加载命令行，就可以直接使用docker命令了</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run --rm -it hello-world</code></pre></div>\n<h1>3.lima nerdctl是如何工作的？</h1>\n<p><code class=\"language-text\">lima nerdctl</code>是一个组合命令，前半段<code class=\"language-text\">lima</code>代表虚拟机层面的操作，其实<code class=\"language-text\">lima</code>是完整命令<code class=\"language-text\">limactl shell default</code>的简写，这段命令的含义是<code class=\"language-text\">在虚拟机&quot;default&quot;中执行命令</code>。同样的你也可以执行除了<code class=\"language-text\">nerdctl</code>之外的命令:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">➜  ~ limactl shell default uname -a\nLinux lima-default 5.13.0-27-generic #29-Ubuntu SMP Wed Jan 12 17:36:47 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre></div>\n<p>而直接执行<code class=\"language-text\">lima</code>可以直接进入到虚拟机中与当前相同的目录。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">➜  ~ pwd\n/Users/felix\n➜  ~ lima\nfelix@lima-default:/Users/felix$ pwd\n/Users/felix</code></pre></div>\n<p>上文提到了默认情况下Lima会把整个<code class=\"language-text\">$HOME</code>挂在到虚拟机中，这个机制目前是使用<a href=\"https://github.com/lima-vm/sshocker/blob/v0.2.0/pkg/reversesshfs/reversesshfs.go\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">reverse sshfs</a>实现的，未来可能会切换至<a href=\"https://wiki.qemu.org/Documentation/9p\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">9p</a>或者<a href=\"https://www.samba.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">samba</a>协议。</p>\n<p>既然可以自由进入linux虚拟机，那么我们也可以摆脱MacOS的限制，在虚拟机内对这个基于<code class=\"language-text\">containerd</code>的<code class=\"language-text\">nerdctl</code>一探究竟。</p>\n<p>在虚拟机中运行<code class=\"language-text\">nerdctl info</code>观察输出结果:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Client:\n Namespace:     default\n Debug Mode:    false\n\nServer:\n Server Version: v1.5.9\n Storage Driver: fuse-overlayfs\n Logging Driver: json-file\n Cgroup Driver: systemd\n Cgroup Version: 2\n Plugins:\n  Log: json-file\n  Storage: native overlayfs fuse-overlayfs stargz\n Security Options:\n  apparmor\n  seccomp\n   Profile: default\n  cgroupns\n  rootless\n Kernel Version: 5.13.0-27-generic\n Operating System: Ubuntu 21.10\n OSType: linux\n Architecture: x86_64\n CPUs: 4\n Total Memory: 3.828GiB\n Name: lima-default\n ID: 53d27d11-7cdf-4094-83d8-223afa776445</code></pre></div>\n<p>我们得以得到几个信息：</p>\n<ul>\n<li>默认的储存引擎是<a href=\"https://github.com/containers/fuse-overlayfs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fuse-overlayfs</a></li>\n<li>Cgroup的默认版本是V2</li>\n<li>启用了Cgroup namespace</li>\n</ul>\n<p>那么我们就来看看他针对某一个container的Cgroup配置是怎么样的吧:\n首先使用<code class=\"language-text\">ps aux</code>找到虚拟机中容器的pid，然后在<code class=\"language-text\">/proc/${pid}</code>目录下找到Cgroup配置的位置:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">felix@lima-default$ cat /proc/10921/cgroup\n0::/user.slice/user-501.slice/user@501.service/user.slice/nerdctl-92a880a7b55ea13a751ea30b7fceff8bd66dd74516d092b40246538662d18762.scope</code></pre></div>\n<p>加上Cgroup目录默认的前缀<code class=\"language-text\">/sys/fs/cgroup</code>我们就能得到这个容器Cgroup配置的地址，进入文件夹后就能看到所有的配置了。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">felix@lima-default:/sys/fs/cgroup/user.slice/user-501.slice/user@501.service/user.slice/nerdctl-92a880a7b55ea13a751ea30b7fceff8bd66dd74516d092b40246538662d18762.scope$ ls\n\ncgroup.controllers  cgroup.max.descendants  cgroup.threads  cpu.stat        cpu.weight.nice        cpuset.mems            io.stat         memory.events.local  memory.min        memory.stat          memory.swap.max\ncgroup.events       cgroup.procs            cgroup.type     cpu.uclamp.max  cpuset.cpus            cpuset.mems.effective  io.weight       memory.high          memory.numa_stat  memory.swap.current  pids.current\ncgroup.freeze       cgroup.stat             cpu.max         cpu.uclamp.min  cpuset.cpus.effective  io.max                 memory.current  memory.low           memory.oom.group  memory.swap.events   pids.events\ncgroup.max.depth    cgroup.subtree_control  cpu.pressure    cpu.weight      cpuset.cpus.partition  io.pressure            memory.events   memory.max           memory.pressure   memory.swap.high     pids.max</code></pre></div>\n<p>可以看到整个Cgroup地址的规律是<code class=\"language-text\">/sys/fs/cgroup/user.slice/user-{uid}.slice/user@{uid}.service/user.slice/nerdctl-${containerHash}.scope</code></p>\n<p>同样的，探索Lima虚拟中的iptables规则也非常简单</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">felix@lima-default:/Users/felix$ <span class=\"token function\">sudo</span> iptables -t nat -nv -L PREROUTING\n<span class=\"token comment\"># Warning: iptables-legacy tables present, use iptables-legacy to see them</span>\nChain PREROUTING <span class=\"token punctuation\">(</span>policy ACCEPT <span class=\"token number\">0</span> packets, <span class=\"token number\">0</span> bytes<span class=\"token punctuation\">)</span>\n pkts bytes target     prot opt <span class=\"token keyword\">in</span>     out     <span class=\"token builtin class-name\">source</span>               destination         \n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DNAT       udp  --  *      *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">192.168</span>.5.3          udp dpt:53 to:192.168.5.2:62883\n    <span class=\"token number\">0</span>     <span class=\"token number\">0</span> DNAT       tcp  --  *      *       <span class=\"token number\">0.0</span>.0.0/0            <span class=\"token number\">192.168</span>.5.3          tcp dpt:53 to:192.168.5.2:57612</code></pre></div>\n<h1>4.还是更喜欢Docker？</h1>\n<p>现在我们知道了，<code class=\"language-text\">lima</code>仅仅提供了虚拟机的解决方案，那么我们是不是可以抛弃<code class=\"language-text\">nerdctl</code>，直接在虚拟机里用的docker呢？实际上Lima官方就有对<a href=\"https://github.com/lima-vm/lima/blob/master/examples/docker.yaml\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">docker</a>和<a href=\"https://github.com/lima-vm/lima/blob/master/examples/podman.yaml\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">podman</a>的支持，以docker为例子，下载对应的docker.yaml后，使用这个配置启动虚拟机即可:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">limactl start docker.yaml</code></pre></div>\n<p>这样，除了<code class=\"language-text\">default</code>之外还会多出一个叫<code class=\"language-text\">docker</code>的虚拟机，所有对这个虚拟机的命令都需要用完整命令<code class=\"language-text\">limactl shell docker</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">limactl shell docker docker run --rm -it hello-world</code></pre></div>\n<p>命令中第一个<code class=\"language-text\">docker</code>是虚拟机的名字而第二个<code class=\"language-text\">docker</code>是docker命令。</p>\n<h1>5.More Than Docker</h1>\n<p>Lima + nerdctl这种模块分离各司其职的设计着实让人眼前一亮，相较于Docker desktop来说灵活性大大地提升了。尤其是对使用MacOS又不想开Linux虚拟机的人来说，Lima轻量级的虚拟机加方便易用的配置和命令能有效地帮助我们摆脱MacOS的桎梏，直接探索Linux和容器技术。另一方面nerdctl作为<code class=\"language-text\">containerd</code>的\"亲儿子\"，不仅提供了与docker兼容的api，更有<a href=\"https://apparmor.net/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AppArmor</a>等Docker并不原生支持的功能。</p>\n<p>自从<a href=\"https://opencontainers.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">OCI</a>标准诞生，并被Kubernetes等实事上的行业标准接纳后，不断涌现出了非常多优秀的实现，而各个云平台也纷纷退出了诸如<a href=\"https://firecracker-microvm.github.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Firecracker</a>等自研的容器运行时。安全容器与虚拟机容器(e.g. <a href=\"https://katacontainers.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kata Containers</a>)的概念也逐渐萌生，着实让人为Docker的商业化道路捏一把汗。</p>\n<h3>参考链接</h3>\n<ol>\n<li><a href=\"https://github.com/lima-vm/lima\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/lima-vm/lima</a></li>\n<li><a href=\"https://github.com/containerd/nerdctl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/containerd/nerdctl</a></li>\n<li><a href=\"https://dockerbook.tw/docs/alternatives/lima\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://dockerbook.tw/docs/alternatives/lima</a></li>\n</ol>","excerpt":"在2021年8月31日，Docker官方发布了一条博客表明了Docker desktop即将进入订阅收费制模式，并给了一段缓冲期至到2022年1月31日。这也意味着从2022年2月1日开始，所有将Docker用于商业目的，公司规模大于250人或者年收大于一千万美元的公司必须缴纳订阅费用了。虽然个人，非盈利组织和教育机构并不会被收费，但除了Docker desktop之外，还有没有一个适用于Mac平台的容器解决方案以便于日常的开发工作呢？ 得益于Linux内核对于Namespace与Cgroup…","frontmatter":{"date":"January 27, 2022","path":"/lima-alternative-docker-desktop-for-mac","title":"Lima: Docker Desktop for Mac的平替？"}}},"pageContext":{}},"staticQueryHashes":["1176552510","3649515864","63159454","846684790"]}